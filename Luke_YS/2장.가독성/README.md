💻 **좋은 코드 - 가독성**
=============

코틀린은 간결성을 목표로 설계된 게 아니라, 사실 **가독성(readability)**을 좋게하는데 목표를 두고 설계된 프로그래밍 언어이다.

코틀린을 사용하면 **깨끗하고 의미 있는 코드**와 **API를 쉽게 작성**할 수 있고,

우리가 **원하는 것을 숨기거나 강조**할 수 있게 하는 기능도 많이 제공한다. 

이러한 기능들을 사용하는 방법을 알아보자.

---



## 📖 가독성을 목표로 설계하라

개발자는 어떤 코드를 작성하는 것보다 **읽는데 많은 시간을 소모**한다. (사실 키보드를 치고 있는 시간보다 머리싸매고 고민하는 시간이 많지 않은가)

따라서 프로그래밍은 **쓰기보다 읽기가 중요**하다는 의미이다. 따라서 항상 **가독성을 생각하면서 코드를 작성**해야 한다.



### ✓  인식 부하 감소

다음 두 코드를 살펴 보자.

```kotlin
//구현 A
if(person != null && person.isAdult) {
	view.showPerson(person)
} else {
	view.showError()
}

//구현 B
person?.takeIf { it.isAdult }
	?.let(view::showPerson)
	?: view.showError()
```

어떤 코드가 더 좋냐고 물어봤을 때 B가 더 짧아서 B라고 대답했다면 사실 틀렸다.

**가독성이란 코드를 읽고 얼마나 빠르게 이해할 수 있는지를 의미**한다.

경험이 많은 개발자라면 상대적으로 A보다 복잡한 관용구에 익숙할 수 있지만 초보자에겐 이해하기 어려울 수 있다.

하지만 **숙련된 개발자만을 위한 코드는 좋은 코드가 아니다**. (코드를 읽는 모두에게 가독성이 좋아야 좋은 코드라고 할 수 있음)



코틀린은 **대부분의 개발자들에게 있어 첫 번째 프로그래밍 언어가 아니다**. 대부분의 코틀린 개발자들은 코틀린보다 다른 언어에 익숙할 가능성이 높다.

또한, 구현 A의 코드는 **수정하기 용이**하다. if블록에 작업을 추가하기 훨씬 쉬운 반면 B는 코드 자체를 뜯어야 한다.

그리고 또, 구현 A는 **디버깅도 더 간단**하다. 일반적으로 디버깅 도구조차 이러한 기본 구조를 더 잘 분석해 준다.

구현 B는 상대적으로 '굉장히 창의적인' 구조이지만, 일반적이지 않고 유연하지도 않고 지원도 제대로 받지 못한다.



이처럼 익숙하지 않은 구조를 사용하면, 잘못된 동작을 코드로 보면서 확인하기 어렵다.

따라서 코드를 좋은 코드를 작성하기 위해 항상 **인지 부하**를 **줄이는 방향**으로 작성해야 한다.



### ✓  극단적이 되지 않기

앞의 인지 부하 챕터에서 인지의 용이에 대해 유용한 관용구들의 사용이 불편할 수 있다고 하였지만, 그렇다고 **너무 극단적으로 되면 안된다**.

예를 들어 전 챕터에서 let으로 인해서 예상하지 못한 결과가 나올 수 있다고 했지만, let은 좋은 코드를 만들기 위해서 다양하게 활용되는 인기 있는 관용구 이다. 

이와 같이 관용구는 널리 사용되며, 많은 사람이 쉽게 인식한다. 

따라서, **인지 부하**와 **코드의 효율성** 사이에서 적절하게 지불할 만한 가치가 있는 비용인지 판단하는 것이 중요하다.

좋은 코드를 위해서 어떤 구조들이 어떤 복잡성을 가져오는지 등을 판단하는 것이 좋다.



### ✓  컨벤션

많은 개발에서 **함수 이름을 어떻게 지어야 하는지**, **어떤 것이 명시적이어야 하는지**, **어떤 것이 암묵적이어야 하는지**, **어떤 관용구를 사용해야하는지** 등으로 토론하곤 한다. 다음 코드를 보고 이 때 지켜야할 몇 가지 규칙을 알아보자.

```kotlin
val abc = "A" { "B" } and "C"
print(abc)	//ABC
```

```kotlin
operator fun String.invoke(f: ()->String): String = this +f()

infix fun String.and(s: String) = this + s
```

> * 연산자는 의미에 맞게 사용해야 한다.
> * '람다를 마지막 마규먼트로 사용한다'라는 컨벤션을 여기에 적용하면, 코드가 복잡해진다.
> * and라는 함수 이름이 실제 함수 내부에서 이루어지는 처리와 맞지 않는다.
> * 문자열을 결합하는 기능은 이미 언어에 내장되어 있다.

---



## 📖 연산자 오버로드를 할 때는 의미에 맞게 사용하라

연산자 오버로딩은 **굉장히 강력한 기능**이지만, **매우 위험한 선택**이 될 수 있다.

```kotlin
fun Int.factorial(): Int = (1..this).product()

fun Iterable<Int>.product(): Int = fold(1) { acc, i -> acc * i }
```

이 함수는 Int 확장 함수로 정의되어 있으므로, 굉장히 편리하게 factorial을 표현할 수 있다.

```kotlin
print(10 * 6.factorial())			//7200 
```

중고등학교 수학 시간에 factorial을 다음과 같이 표현한다는 것을 배웠을 것이다.

```kotlin
10 * 6!
```

코틀린은 이런 연산자를 지원하지 않지만, 다음과 같이 연산자 오버로딩을 활용하면 만들어 낼 수 있다.

```kotlin
operator fun Int.not() = factorial()

print(10 * !6)		//7200
```

이렇게 할 수는 있지만 not이라는 용어는 논리 연산에 사용해야지, 팩토리얼 연산에 사용하면 안된다.

코드는 이렇게 작성하면 굉장히 혼란스럽고 오해의 소지가 있을 수 있다.

**코틀린에서 연산자에 대응되는 함수 이름들**을 살펴보면 **매우 중요한 설계 결정**인 것을 눈으로 확인할 수 있다.

스칼라(Scala)와 같은 일부 언어는 **무제한 연산자 오버로딩(unlimited operator overloading)**을 지원하지만, 이 정도의 자유는 많은 개발자가 해당 **기능을 오용**하게 만들곤 한다.

하지만 코틀린에서는 각각의 **연산자에 구체적인 의미가 있으므로** 이러한 문제가 없다. 예를 들어 다음 코드를 보자.

```kotlin
x + y == z
```

이 코드는 언제나 다음과 같은 코드로 변환된다.

```kotlin
x.plus(y).equal(z)
```

참고로 만약 plus의 리턴 타입이 nullable이라면, 다음과 같이 변환된다.

```kotlin
(x.plus(y))?.equal(z) ?: (z == null)
```

이는 **구체적인 이름을 가진 함수**이며 **모든 연산자가 이러한 이름이 나타내는 역할을 할 것**이라고 기대된다.

이처럼 이름만으로 **연산자의 사용이 크게 제한**되므로 factorial을 계산하기 위해서 **! 연산자를 함부로 남용해서는 안된다**. (관례에 어긋남)



### ✓  관례를 충족하는지 아닌지 분명하지 않은 경우

예를 들어 한수를 3배 한다는 것은 무슨 의미일까?

어떤 사람은 다음과 같이 이 함수를 3번 반복하는 새로운 함수를 만들어 낸다고 생각할 수 있다.

```kotlin
operator fun Int.times(operation: () -> Unit): ()->Unit = { repeat(this) { operation() } }

val tripledHello = 3 * { print("Hello") }

tripledHello()	//출력: HelloHelloHello
```

물론 어떤 사람은 다음과 같이 이러한 코드가 함수를 3번 호출한다는 것을 쉽게 이해할 수 있을 것이다.

```kotlin
operator fun Int.times(operation: ()->Unit) {
	repeat(this) { operation() }
}

3 * { print("Hello") }	//출력: HelloHelloHello
```

의미가 명확하지 않다면 infix를 활용한 확장 함수를 사용하는 것이 좋다. **일반적인 이항 연산자 형태**처럼 사용할 수 있다.

```kotlin
infix fun Int.timesRepeated(operation: ()->Unit) = {
	repeat(this) { operation() }
}

val tripledHello = 3 timesRepeated { print("Hello") }
tripledHello()	//출력: HelloHelloHello
```

**톱레벨 함수(top-level function)**를 사용하는 것도 좋다. 사실 근데 함수를  n번 호출하는 것은 다음과 같은 형태로 이미 stdlib에 구현 되어있긴 하다.

```kotlin
repeat(3) { print("Hello") }
```



### ✓  규칙을 무시해도 되는 경우

**도메인 특화 언어(Domain Specific Language, DSL)**를 설계할 때는 앞에서 설명한 연산자 오버로딩 규칙을 무시해도 된다.

고전적인 HTML DSL을 생각해보자.

```kotlin
body {
	div {
		+"Some text"
	}
}
```

문자열 앞에 String.unaryPlus가 사용된 것을 볼 수 있다. 이렇게 코드를 작성할 수 있는 이유는 이 코드가 DSL 코드이기 때문이다.



### ✓  챕터 정리

연산자 오버로딩은 꼭 그 **이름의 의미에 맞게** 사용해야 한다. 

연산자 **의미가 명확하지 않다면 연산자 오버로딩 자체를 사용하지 않는 것**이 좋다. 대신 이름이 있는 일반 함수를 사용한다. 

꼭 연산자의 형태로 사용해야 한다면, **infix 확장 함수 또는 톱레벨 함수**를 활용하자.

---



## 📖 Unit?을 리턴하지 말라

Boolean이 true와 false를 같는 것처럼 Unit? 또한 Unit 또는 null이라는 값을 가질 수 있다. 따라서 Boolean과 Unit? 타입은 서로 바꿔서 사용할 수 있다. 일반적으로 Unit?을 사용하는 경우는 다음과 같은 경우다.

```kotlin
fun keyIsCorrect(key: String): Boolean = //...

if(!keyIsCorrect(key)) return
```

다음처럼 사용할 수도 있다.

```kotlin
fun verifyKey(key: String): Unit? = //...

verifyKey(key) ?: return
```

이러한 코드는 작성할 때야 멋있게 보일 수도 있겠지만, 읽을 때는 그렇지 않다.

**Unit?으로 Boolean을 표현하는 경우 오해의 소지가 있으며, 예측하기 어려운 오류를 만들 수 있다.**

지금까지 여러코드를 보면서 Unit?을 쉽게 읽을 수 있는 경우는 거의 보지 못했다. 이러한 코드는 오해를 불러 일으키기 쉽다.

따라서 **Boolean을 사용하는 형태로 변경**해야 한다. 기본적으로 Unit?을 리턴하거나, 이를 기반으로 연산하지 않는 것이 좋다.

---



## 📖 변수 타입이 명확하지 않은 경우 확실하게 지정하라

코틀린은 개발자가 타입을 지정하지 않아도, 타입을 지정해서 넣어 주는 굉장히 수준 높은 타입 추론 시스템을 갖추고 있다.

```kotlin
val num = 10
val name = "Luke"
val ids = listOf(12, 112, 554, 997)
```

이는 개발 시간을 줄일 뿐만 아니라 유형이 명확할 때 코드가 짧아지므로 코드의 가독성이 크게 향상된다. 

하지만 **유형이 명확하지 않을 때는 남용하지 않는 게 좋다.**

```kotlin
val data = getSomeData()
```

위의 코드는 타입을 숨기고 있다. 가독성을 위해 **코드를 설계할 때 읽는 사람에게 중요한 정보를 숨겨서는 안된다.**

따라서 이런 경우 다음과 같이 **타입을 지정하여 명시**해주어 코드를 훨씬 쉽게 읽을 수 있도록 해야한다.

```kotlin
val data: UserData = getSomeData()
```

가독성 향상 이외에 안전을 위해서도 타입을 지정하는 것이 좋다.

타입은 개발자와 컴파일러 모두에게 중요한 정보이다. 그렇다고 타입을 무조건 지정하라는 것이 아니라 상황에 맞게 잘 사용해야 한다.

---



## 📖 리시버를 명시적으로 참조하라

리시버란 무엇인가? 리시버는 무언가를 더 자세하게 설명하기 위해서, **명시적으로 긴 코드를 사용할 때** 함수와 프로퍼티를 지역 또는 톱레벨 변수가 아닌 리시버로부터 가져온다는 것을 나타낼 때가 있다. 대표적으로 클래스의 메서드를 나타내기 위한 **this**를 예로 들 수 있다.

다음 퀵소트 구현을 살펴보자.

```kotlin
fun <T : Comparable<T>> List<T>.quickSort(): List<T> {
	if (size < 2) return this
	val pivot = first()
	val (smaller, bigger) = drop(1)
		.partition { it < pivot }
	return smaller.quickSort() + pivot + bigger.quickSort()
}
```

이 같은 퀵소트의 명시적 구현을 다음과 같이 표현할 수 있다.

```kotlin
fun <T : Comparable<T>> List<T>.quickSort(): List<T> {
	if (this.size < 2) return this
	val pivot = this.first()
	val (smaller, bigger) = this.drop(1)
		.partition { it < pivot }
	return smaller.quickSort() + pivot + bigger.quickSort()
}
```



### ✓  여러 개의 리시버가 있는 경우

스코프 내부의 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내면 더욱 효과를 볼 수 있다. **apply, with, run**을 사용할 때가 대표적이다.

```kotlin
class Node(val name: String) {
	fun makeChild(childName: String) = 
		create("$name.$childName")
			.apply { print("Created ${name}") }
  		//apply 함수 내부의 this 타입이 Node?라서 컴파일 오류가 남. (name -> this?.name으로 바꿔주어야 함)
}

fun main() {
	val node = Node("parent")
	node.makeChild("child")
}
```

사실 이는 apply의 잘못된 사용이다. (?왜 알려준거야)

also와 파라미터 name을 사용했다면, 이러한 문제 자체가 일어나지 않는다.

```kotlin
clazs Node(val name: String) {
	fun makeChild(childName: String) =
		create("$name.$childName")
			.also { print("Created ${it?.name}") }
			
	fun create(name: String): Node? = Node(name)
}
```

일반적으로 이처럼 **also** 또는 **let**을 사용하는 것이 **nullable 값을 처리할 때** 훨씬 좋은 선택지가 될 수 있다.

리시버가 명확하지 않다면, 명시적으로 리시버를 적어서 이를 명확하게 해 주어야 한다. (레이블을 사용한 외부리시버 가져오기)

```kotlin
class Node(val name: String) {
	fun makeChild(childName: String) =
		create("$name.$childName").apply {
			print("Created ${this?.name} in " +
				"${this@Node.name}")	//이처럼 레이블을 사용하여 외부 리시버를 사용
		}
		
		fun create(name: String):Node? = Node(name)
}

fun main() {
	val node = Node("parent")
	node.makeChild("child")
  //Created parent.child in parent
}
```



### ✓  DSL 마커

보통을 여러 리시버를 가진 요소들이 중첩되더라도, 리시버를 명시적으로 붙이지 않는다. 하지만 DSL에서는 외부의 함수를 사용하는 것이 위험한 경우가 있다. 예를 들어 HTML table 요소를 만든느 **HTML DSL**을 생각해 보자.

```kotlin
table {
	tr {
		td { +"Column 1" }
		td { +"Column 2" }
	}
	tr {
		td { +"Value 1" }
		td { +"Value 2" }
	}
}
```

이러한 코드는 기본적으로 모든 스코프에서 외부 스코프에 있는 리시버의 메소드를 사용할 수 있지만, 다음과 같은 코드는 경우가 다르다.

```kotlin
table {
	tr {
		td { +"Column 1" }
		td { +"Column 2" }
    tr {
			td { +"Value 1" }
			td { +"Value 2" }
		}
	}
}
```

이러한 잘못된 사용을 막으려면, 암묵적으로 외부 리시버 사용을 막는 **DslMarker라는 메타 어노테이션**을 사용합니다. (어노테이션을 위한 어노테이션)

```kotlin
@DslMarker
annotation class HtmlDsl

fun table(f: TableDsl.() -> Unit) { /*...*/ }

@HtmlDsl
class TableDsl { /*...*/ }
```

이렇게 작성하면 **암묵적인 리시버 사용이 금지**된다.

```kotlin
table {
	tr {
		td { +"Column 1" }
		td { +"Column 2" }
    this@table.tr {		//이와 같이 레이블로 명시하지 않으면 오류남
			td { +"Value 1" }
			td { +"Value 2" }
		}
	}
}
```

DSL 마커는 가장 가까운 리시버만을 사용하게 하거나, 명시적으로 외부 리시버를 사용하지 못하게 할 때 활용할 수 있는 중요한 메커니즘이다.

DSL 설계에 따라서 사용 여부를 결정하는 것이 좋으므로, 설계에 따라서 사용하기 바랍니다.



### ✓  챕터 정리

코드를 줄이겠다는 이유만으로 리시버를 제거하는 멍청한 짓은 하지 말자. 특히나 **다양한 리시버가 있는 경우**에는 **리시버를 명시적으로** 적어 주는 것이 코드 리뷰를 하거나 남들이 분석할 때 **가독성** 측면에서 더욱더 효과적으로 다가올 수 있다. DSL에서 외부 스코프에 있는 리시버를 명시적으로 적게 강제하고 싶을 때는 DslMarker 어노테이션을 사용한다.

---



## 📖 프로퍼티는 동작이 아니라 상태를 나타내야 한다

코틀린의 프로퍼티는 자바의 필드와 비슷해 보이지만 사실 서로 완전 다른 개념이다.

```kotlin
//Kotlin의 프로퍼티
val name: String? = null

//Java의 필드
String name = null;
```

데이터를 제ㅓ장한다는 점은 같지만, 프로퍼티에는 더 많은 기능이 있다.

일단 기본적으로 프로퍼티는 사용자 정의 세터와 게터를 가질 수 있다.

```kotlin
var name: String? = null
	get() = field?.toUpperCase()
	set(value) {
		if(!value.isNullOrBlank()) {
			field = value
		}
	}
```

코드에서 field라는 식별자를 확인할 수 있는데, 이를 프로퍼티의 데이터를 저장해 두는 **백킹 필드(backing field)**라고 한다.

이러한 **백킹 필드는 세터와 게터의 디폴트 구현에 사용**되므로, 따로 만들지 않아도 디폴트로 생성된다.

**val을 사용해서 읽기 전용 프로퍼티를 만들 때는 field가 만들어지지 않는다.**

var을 사용해서 만든 읽고 쓸 수 있는 프로퍼티는 게터와 세터를 정의할 수 있다. 이러한 프로퍼티를 **파생 프로퍼티(derived property)**라고 부르며, 자주 사용된다.

이처럼 코틀린의 모든 프로퍼티는 디폴트로 **캡슐화**되어 있다. 

다음 코드를 살펴보자.

```kotlin
var date: Date
	get() = Date(millis)
	set(value) {
		millis = value.time
	}
```

Date를 활용해 객체에 날짜를 저장해서 많이 활용했다고 가정할 때, 직렬화 문제 등으로 더이상 이러한 타입으로 객체를 저장할 수 없게 됐다고 생각해보자.

이미 프로젝트 전체에서 이 프로퍼티를 많이 참조하고 있다면 어떻게 해야할까? 

코틀린은 데이터를 milllis라는 별도의 프로퍼티로 옮기고, 이를 활용해서 date 프로퍼티에 데이터를 저장하지 않고, 랩(wrap)/언랩(upwrap)하도록 코드를 변경하기만 하면 된다.

프로퍼티는 필드가 필요 없다. 오히려 프로퍼티는 개념적으로 **접근자**(val의 경우 게터, var의 경우 게터와 세터)를 나타낸다.

따라서 코틀린은 **인터페이스에도 프로퍼티를 정의**할 수 있다.

```kotlin
interface Person {
	val name: String
}
```

이렇게 코드를 작성하면, 이는 게터를 가질 것이라는 것을 나타낸다.

따라서 다음과 같이 **오버라이드**할 수 있다.

```kotlin
open class Supercomputer {
	open val theAnswer: Long = 42
}

class AppleComputer: SuperComputer {
	override val theAnswer: Long = 1_800_275_2273
}
```

마찬가지의 이류로 프로퍼티를 위임할 수 도 있다.

```kotlin
val db: Database by lazy { connectToDb() }
```

**프로퍼티 위임(property delegation)**은 뒤에서 자세히 설명할 것이다. (21번째 아이템)

프로퍼티는 본질적으로 함수이므로, 확장 프로퍼티를 만들 수도 있다. 하지만 완전히 **함수를 완전히 대체해서 사용하는 것은 좋지 않다.**

다음을 보자.

```kotlin
val Tree<Int>.sum: Int
	get() = when (this) {
		is Leaf -> value
		is Node -> left.sum + right.sum
	}
```

여기서 sum 프로퍼티는 모든 요소를 반복처리하므로, 알고리즘의 동작을 나타낸다고 할 수 있다.

이러한 프로퍼티는 여러 가지 오해를 불러 일으킬 수 있다. 큰 컬렉션의 경우 답을 찾을 때, **많은 계산량이 필요**한데, 관습적으로 **이러한 게터에 그런 계산량이 필요하다고 예상하지는 않는다**. 따라서 이러한 처리는 프로퍼티가 아닌 함수로 구현해야 한다.

원칙적으로 프로퍼티는 **상태를 나타내거나 설정하기 위한 목적**으로만 사용하는 것이 좋고, **다른 로직 등을 포함하지 않아야 한다.**

**"이 프로퍼티를 함수로 정의할 경우, 접두사로 get 또는 set을 붙일 것인가?"** 만약 아니라면, 이를 프로퍼티로 만드는 것은 좋지 않다.

조금 더 구체적으로 프로퍼티 대신 함수를 사용하는 것이 좋은 경우를 정리해 보면, 다음과 같다.

> + **연산 비용이 높거나, 복잡도가 O(1)보다 큰 경우** (관습적으로 연산 비용이 많이 필요하다고 생각하지 않음)
> + **비즈니스 로직(애플리케이션의 동작)을 포함하는 경우** (단순한 동작 이상을 할 거라고 기대하지 않음)
> + **결정적이지 않은 경우** (같은 동작을 여러번 했는데, 다른 값이 나올 때)
> + **변환의 경우** (변환은 변환 함수로 만들자)
> + **게터에서 프로퍼티의 상태 변경이 일어나야 하는 경우** (함수를 사용하자)

많은 사람은 경험적으로, **프로퍼티는 상태 집합**을 나타내고, **함수는 행동**을 나타낸다고 생각한다.

---



## 📖 이름 있는 아규먼트를 사용하라

코드에서 아규먼트의 의미가 명확하지 않은 경우가 있다.

```kotlin
val text = (1..10).joinToString("|")
```

"|"는 무엇을 의미할까? 만약 joinToString에 대해서 이미 알고 있다면, 이것이 **구분자(separator)**를 의미한다는 것을 알 것이다.

하지만 모른다면, 이것이 **접두사(prefix)**로 생각할 수도 있을 것이다. 따라서 명확하지 않게 보일 수도 있다.

**파라미터가 명확하지 않은 경우에는 이를 직접 지정해서 명확하게 만들어 줄 수 있다.**

```kotlin
val text = (1..10).joinToString(seperator = "|")
```

또는 다음처럼 **변수를 사용해서 의미를 명확**하게 할 수 있다.

```kotlin
val separator = "|"
val text = (1..10).joinToString(seperator)
```

변수 이름을 사용하는 방법도 개발자의 의도를 쉽게 알 수 있지만, 실제로 코드에서 제대로 사용되고 있는지는 알 수 없다.

이름 있는 아규먼트를 사용한다면 이러한 문제가 발생하지 않는다.

```kotlin
val separator = "|"
val text = (1..10).joinToString(seperator = separator)
```



### ✓ 이름 있는 아규먼트는 언제 사용해야 할까?

이름 있는 아규먼트를 사용하면 코드가 길어지지만, 다음과 같은 두 가지 장점이 생긴다.

+ **이름을 기반으로 값이 무엇을 나타내는지 알 수 있다.**
+ **파라미터 입력 순서와 상관 없으므로 안전하다.**

아규먼트 이름은 함수를 사용하는 개발자 뿐만 아니라 **코드를 읽는 사람들에게도 굉장히 중요한 정보**이다.

```kotlin
sleep(100)
```

이 코드는 얼마나 sleep하는 걸까? 100ms? 100s? 명확하지 않다.

```kotlin
sleep(timeMillis = 100)
```

이렇게 이름 있는 아규먼트를 활용하면 명확하게 표현이 가능하다.

다음과 같은 경우에는 더욱더 추천한다.

+ 디폴트 아규먼트의 경우
+ 같은 타입의 파라미터의 많은 경우
+ 함수 타입의 파라미터가 있는 경우 (마지막 파라미터의 경우 제외)



### ✓ 디폴트 아규먼트의 경우

디퐅르 아규먼트를 가질 경우, 항상 이름을 붙여서 사용하는 게 좋다. 

일반적으로 함수 이름은 **필수 파라미터들과 관련**되어 있기 때문에 디폴트 값을 갖는 **옵션 파라미터(optional parameter)의 설명이 명확하지 않다.**

따라서 이름을 붙여서 사용하는 것이 좋다.



### ✓ 같은 타입의 파라미터가 많은 경우

파라미터가 모두 다른 타입이라면, 위치를 잘못 입력하면 오류가 발생할 것이므로 쉽게 문제를 발견할 수 있다.

하지만 파라미터에 같은 타입이 있다면, 잘못 입력했을 때 문제를 찾아내기 어려울 수 있다.

```kotlin
fun sendEmail(to: String, meassage: String) { */...*/ }
```

이러한 함수가 있다면, 이름 있는 아규먼트를 사용하는 것이 좋다.

```kotlin
sendEmail(
	to = "contact@kt.academy",
	message = "Hello, ..."
)
```



### ✓ 함수 타입 파라미터

repeat과 thread와 같이 **마지막에 위치하는 함수 파라미터 이외에 모든 함수 타입 아규먼트는 이름 있는 아규먼트를 사용하는 것이 좋다.**

또한 여러 **함수 타입의 옵션 파라미터가 있는 경우**에는 더 헷갈리게 된다. 이러한 경우 역시 이름을 붙여 사용하면 훨씬 쉽게 이해할 수 있다.



### ✓ 챕터 정리

이름 있는 아규먼트는 디폴트 값들을 생략할 때만 유용한 것이 아니다. 이름 있는 아규먼트는 개발자가 코드를 읽을 때도 편리하게 활용되며, 코드의 안정성도 향상시킬 수 있다. 또한 함수에 **같은 타입의 파라미터가 여러 개 있는 경우**, **함수 타입의 파라미터가 있는 경우**, **옵션 파라미터가 있는 경우**에는 이름 있는 아규먼트를 활용하는 것이 좋다.

---



## 📖 코딩 컨벤션을 지켜라

코틀린에서 설명하는 **코딩 컨벤션**은 다음과 같다.

+ **어떤 프로젝트를 접해도 쉽게 이해할 수 있다.**
+ **다른 외부 개발자도 프로젝트의 코드를 쉽게 이해할 수 있다.**
+ **다른 개발자도 코드의 작동 방식을 쉽게 추측할 수 있다.**
+ **코드를 병합하고, 한 프로젝트의 코드 일부를 다른 코드로 이동하는 것이 쉽다.**

컨벤션을 지킬 때 도움이 되는 두 가지 도구가 있다.

+ **IntelliJ 포매터(formatter)**: 공식적 코딩 컨벤션 스타일에 맞춰서 코드를 변경해줌
+ **Ktlint**: 많이 사용되는 코드를 분석하고 컨벤션 위반을 알려 주는 린터

**프로젝트 컨벤션은 반드시 지켜 주는 것이 좋다.**

프로젝트의 모든 코드는 여러 사람이 싸우는 느낌으로 작성되면 안 되며, 마치 **한 사람이 작성한 것처럼 작성**되어야 한다.

많은 개발자가 코딩 컨벤션을 지키지 않는다. 하지만 코딩 컨벤션은 굉장히 중요하다.

코딩 컨벤션을 확실하게 읽고, 정적 검사기(static checker)를 활용해서 프로젝트의 **코딩 컨벤션 일관성을 유지해야 한다.**

---

* Effective Kotlin - 마르친 모스칼라 지음
