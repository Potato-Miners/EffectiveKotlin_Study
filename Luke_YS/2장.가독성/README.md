💻 **좋은 코드 - 가독성**
=============

코틀린은 간결성을 목표로 설계된 게 아니라, 사실 **가독성(readability)**을 좋게하는데 목표를 두고 설계된 프로그래밍 언어이다.

코틀린을 사용하면 **깨끗하고 의미 있는 코드**와 **API를 쉽게 작성**할 수 있고,

우리가 **원하는 것을 숨기거나 강조**할 수 있게 하는 기능도 많이 제공한다. 

이러한 기능들을 사용하는 방법을 알아보자.

---



## 📖 가독성을 목표로 설계하라

개발자는 어떤 코드를 작성하는 것보다 **읽는데 많은 시간을 소모**한다. (사실 키보드를 치고 있는 시간보다 머리싸매고 고민하는 시간이 많지 않은가)

따라서 프로그래밍은 **쓰기보다 읽기가 중요**하다는 의미이다. 따라서 항상 **가독성을 생각하면서 코드를 작성**해야 한다.



### ✓  인식 부하 감소

다음 두 코드를 살펴 보자.

```kotlin
//구현 A
if(person != null && person.isAdult) {
	view.showPerson(person)
} else {
	view.showError()
}

//구현 B
person?.takeIf { it.isAdult }
	?.let(view::showPerson)
	?: view.showError()
```

어떤 코드가 더 좋냐고 물어봤을 때 B가 더 짧아서 B라고 대답했다면 사실 틀렸다.

**가독성이란 코드를 읽고 얼마나 빠르게 이해할 수 있는지를 의미**한다.

경험이 많은 개발자라면 상대적으로 A보다 복잡한 관용구에 익숙할 수 있지만 초보자에겐 이해하기 어려울 수 있다.

하지만 **숙련된 개발자만을 위한 코드는 좋은 코드가 아니다**. (코드를 읽는 모두에게 가독성이 좋아야 좋은 코드라고 할 수 있음)



코틀린은 **대부분의 개발자들에게 있어 첫 번째 프로그래밍 언어가 아니다**. 대부분의 코틀린 개발자들은 코틀린보다 다른 언어에 익숙할 가능성이 높다.

또한, 구현 A의 코드는 **수정하기 용이**하다. if블록에 작업을 추가하기 훨씬 쉬운 반면 B는 코드 자체를 뜯어야 한다.

그리고 또, 구현 A는 **디버깅도 더 간단**하다. 일반적으로 디버깅 도구조차 이러한 기본 구조를 더 잘 분석해 준다.

구현 B는 상대적으로 '굉장히 창의적인' 구조이지만, 일반적이지 않고 유연하지도 않고 지원도 제대로 받지 못한다.



이처럼 익숙하지 않은 구조를 사용하면, 잘못된 동작을 코드로 보면서 확인하기 어렵다.

따라서 코드를 좋은 코드를 작성하기 위해 항상 **인지 부하**를 **줄이는 방향**으로 작성해야 한다.



### ✓  극단적이 되지 않기

앞의 인지 부하 챕터에서 인지의 용이에 대해 유용한 관용구들의 사용이 불편할 수 있다고 하였지만, 그렇다고 **너무 극단적으로 되면 안된다**.

예를 들어 전 챕터에서 let으로 인해서 예상하지 못한 결과가 나올 수 있다고 했지만, let은 좋은 코드를 만들기 위해서 다양하게 활용되는 인기 있는 관용구 이다. 

이와 같이 관용구는 널리 사용되며, 많은 사람이 쉽게 인식한다. 

따라서, **인지 부하**와 **코드의 효율성** 사이에서 적절하게 지불할 만한 가치가 있는 비용인지 판단하는 것이 중요하다.

좋은 코드를 위해서 어떤 구조들이 어떤 복잡성을 가져오는지 등을 판단하는 것이 좋다.



### ✓  컨벤션

많은 개발에서 **함수 이름을 어떻게 지어야 하는지**, **어떤 것이 명시적이어야 하는지**, **어떤 것이 암묵적이어야 하는지**, **어떤 관용구를 사용해야하는지** 등으로 토론하곤 한다. 다음 코드를 보고 이 때 지켜야할 몇 가지 규칙을 알아보자.

```kotlin
val abc = "A" { "B" } and "C"
print(abc)	//ABC
```

```kotlin
operator fun String.invoke(f: ()->String): String = this +f()

infix fun String.and(s: String) = this + s
```

> * 연산자는 의미에 맞게 사용해야 한다.
> * '람다를 마지막 마규먼트로 사용한다'라는 컨벤션을 여기에 적용하면, 코드가 복잡해진다.
> * and라는 함수 이름이 실제 함수 내부에서 이루어지는 처리와 맞지 않는다.
> * 문자열을 결합하는 기능은 이미 언어에 내장되어 있다.

---



## 📖 연산자 오버로드를 할 때는 의미에 맞게 사용하라

연산자 오버로딩은 **굉장히 강력한 기능**이지만, **매우 위험한 선택**이 될 수 있다.

```kotlin
fun Int.factorial(): Int = (1..this).product()

fun Iterable<Int>.product(): Int = fold(1) { acc, i -> acc * i }
```

이 함수는 Int 확장 함수로 정의되어 있으므로, 굉장히 편리하게 factorial을 표현할 수 있다.

```kotlin
print(10 * 6.factorial())			//7200 
```

중고등학교 수학 시간에 factorial을 다음과 같이 표현한다는 것을 배웠을 것이다.

```kotlin
10 * 6!
```

코틀린은 이런 연산자를 지원하지 않지만, 다음과 같이 연산자 오버로딩을 활용하면 만들어 낼 수 있다.

```kotlin
operator fun Int.not() = factorial()

print(10 * !6)		//7200
```

이렇게 할 수는 있지만 not이라는 용어는 논리 연산에 사용해야지, 팩토리얼 연산에 사용하면 안된다.

코드는 이렇게 작성하면 굉장히 혼란스럽고 오해의 소지가 있을 수 있다.

**코틀린에서 연산자에 대응되는 함수 이름들**을 살펴보면 **매우 중요한 설계 결정**인 것을 눈으로 확인할 수 있다.

스칼라(Scala)와 같은 일부 언어는 **무제한 연산자 오버로딩(unlimited operator overloading)**을 지원하지만, 이 정도의 자유는 많은 개발자가 해당 **기능을 오용**하게 만들곤 한다.

하지만 코틀린에서는 각각의 **연산자에 구체적인 의미가 있으므로** 이러한 문제가 없다. 예를 들어 다음 코드를 보자.

```kotlin
x + y == z
```

이 코드는 언제나 다음과 같은 코드로 변환된다.

```kotlin
x.plus(y).equal(z)
```

참고로 만약 plus의 리턴 타입이 nullable이라면, 다음과 같이 변환된다.

```kotlin
(x.plus(y))?.equal(z) ?: (z == null)
```

이는 **구체적인 이름을 가진 함수**이며 **모든 연산자가 이러한 이름이 나타내는 역할을 할 것**이라고 기대된다.

이처럼 이름만으로 **연산자의 사용이 크게 제한**되므로 factorial을 계산하기 위해서 **! 연산자를 함부로 남용해서는 안된다**. (관례에 어긋남)



### ✓  관례를 충족하는지 아닌지 분명하지 않은 경우

예를 들어 한수를 3배 한다는 것은 무슨 의미일까?

어떤 사람은 다음과 같이 이 함수를 3번 반복하는 새로운 함수를 만들어 낸다고 생각할 수 있다.

```kotlin
operator fun Int.times(operation: () -> Unit): ()->Unit = { repeat(this) { operation() } }

val tripledHello = 3 * { print("Hello") }

tripledHello()	//출력: HelloHelloHello
```

물론 어떤 사람은 다음과 같이 이러한 코드가 함수를 3번 호출한다는 것을 쉽게 이해할 수 있을 것이다.

```kotlin
operator fun Int.times(operation: ()->Unit) {
	repeat(this) { operation() }
}

3 * { print("Hello") }	//출력: HelloHelloHello
```

의미가 명확하지 않다면 infix를 활용한 확장 함수를 사용하는 것이 좋다. **일반적인 이항 연산자 형태**처럼 사용할 수 있다.

```kotlin
infix fun Int.timesRepeated(operation: ()->Unit) = {
	repeat(this) { operation() }
}

val tripledHello = 3 timesRepeated { print("Hello") }
tripledHello()	//출력: HelloHelloHello
```

**톱레벨 함수(top-level function)**를 사용하는 것도 좋다. 사실 근데 함수를  n번 호출하는 것은 다음과 같은 형태로 이미 stdlib에 구현 되어있긴 하다.

```kotlin
repeat(3) { print("Hello") }
```



### ✓  규칙을 무시해도 되는 경우

**도메인 특화 언어(Domain Specific Language, DSL)**를 설계할 때는 앞에서 설명한 연산자 오버로딩 규칙을 무시해도 된다.

고전적인 HTML DSL을 생각해보자.

```kotlin
body {
	div {
		+"Some text"
	}
}
```

문자열 앞에 String.unaryPlus가 사용된 것을 볼 수 있다. 이렇게 코드를 작성할 수 있는 이유는 이 코드가 DSL 코드이기 때문이다.



### ✓  챕터 정리

연산자 오버로딩은 꼭 그 **이름의 의미에 맞게** 사용해야 한다. 

연산자 **의미가 명확하지 않다면 연산자 오버로딩 자체를 사용하지 않는 것**이 좋다. 대신 이름이 있는 일반 함수를 사용한다. 

꼭 연산자의 형태로 사용해야 한다면, **infix 확장 함수 또는 톱레벨 함수**를 활용하자.

---



## 📖 Unit?을 리턴하지 말라

Boolean이 true와 false를 같는 것처럼 Unit? 또한 Unit 또는 null이라는 값을 가질 수 있다. 따라서 Boolean과 Unit? 타입은 서로 바꿔서 사용할 수 있다. 일반적으로 Unit?을 사용하는 경우는 다음과 같은 경우다.

```kotlin
fun keyIsCorrect(key: String): Boolean = //...

if(!keyIsCorrect(key)) return
```

다음처럼 사용할 수도 있다.

```kotlin
fun verifyKey(key: String): Unit? = //...

verifyKey(key) ?: return
```

이러한 코드는 작성할 때야 멋있게 보일 수도 있겠지만, 읽을 때는 그렇지 않다.

**Unit?으로 Boolean을 표현하는 경우 오해의 소지가 있으며, 예측하기 어려운 오류를 만들 수 있다.**

지금까지 여러코드를 보면서 Unit?을 쉽게 읽을 수 있는 경우는 거의 보지 못했다. 이러한 코드는 오해를 불러 일으키기 쉽다.

따라서 **Boolean을 사용하는 형태로 변경**해야 한다. 기본적으로 Unit?을 리턴하거나, 이를 기반으로 연산하지 않는 것이 좋다.

---



## 📖 변수 타입이 명확하지 않은 경우 확실하게 지정하라

코틀린은 개발자가 타입을 지정하지 않아도, 타입을 지정해서 넣어 주는 굉장히 수준 높은 타입 추론 시스템을 갖추고 있다.

```kotlin
val num = 10
val name = "Luke"
val ids = listOf(12, 112, 554, 997)
```

이는 개발 시간을 줄일 뿐만 아니라 유형이 명확할 때 코드가 짧아지므로 코드의 가독성이 크게 향상된다. 

하지만 **유형이 명확하지 않을 때는 남용하지 않는 게 좋다.**

```kotlin
val data = getSomeData()
```

위의 코드는 타입을 숨기고 있다. 가독성을 위해 **코드를 설계할 때 읽는 사람에게 중요한 정보를 숨겨서는 안된다.**

따라서 이런 경우 다음과 같이 **타입을 지정하여 명시**해주어 코드를 훨씬 쉽게 읽을 수 있도록 해야한다.

```kotlin
val data: UserData = getSomeData()
```

가독성 향상 이외에 안전을 위해서도 타입을 지정하는 것이 좋다.

타입은 개발자와 컴파일러 모두에게 중요한 정보이다. 그렇다고 타입을 무조건 지정하라는 것이 아니라 상황에 맞게 잘 사용해야 한다.

---

* Effective Kotlin - 마르친 모스칼라 지음