💻 **객체 생성**
=============

코틀린의 코드는 순수 함수형 스타일로 작성할 수도 있지만, **자바처럼 객체 지향 프로그래밍(OOP) 스타일로도 작성할 수 있다.** 

OOP는 객체를 생성해서 사용하므로, **객체를 생성하는 방법을 정의**해야 한다.

이번 장에서는 객체를 생성하는 방법에는 어떤 것들이 있는지, 그리고 각각의 방법에는 어떤 장점과 단점이 있는지 살펴본다.



## 📖 생성자 대신 팩토리 함수를 사용하라

클라이언트가 클래스의 인스턴스를 만들게 하는 가장 일반적인 방법은 기본 생성자를 사용하는 방법이다. 

```kotlin
class MyLinkedList<T>(
	val head: T,
	val tail: MyLinkedList<T>?
)

val list = MyLinkedList(1, MyLinkedList(2, null))
```

하지만 생성자가 객체를 만들 수 있는 유일한 방법은 아니다.

디자인 패턴으로 굉장히 다양한 생성 패턴(creational pattern)들이 만들어져 있다.

일반적으로 이러한 생성 패턴은 객체를 생성자로 직접 생성하지 않고, 별도의 함수를 통해 생성한다.

이렇게 생성자의 역할을 대신 해 주는 함수를 **팩토리 함수**라고 한다. 

생성자 대신에 팩토리 함수를 사용하면 다양한 장점들이 생긴다.

+ 생성자와 다르게, 함수에 이름을 붙일 수 있다.
+ 생성자와 다르게, 함수가 원하는 형태의 타입을 리턴할 수 있다.
+ 생성자와 다르게, 호출될 때마다 새 객체를 만들 필요가 없다.
+ 아직 존재하지 않는 객체를 리턴할 수 있다.
+ 객체 외부에 팩토리 함수를 만들면, 그 가시성을 원하는 대로 제어할 수 있다.
+ 팩토리 함수는 인라인으로 만들 수 있으며, 그 파라미터들을 reified로 만들 수 있다.
+ 팩토리 함수는 생성자로 만들기 복잡한 객체도 만들어 낼 수 있다.
+ 팩토리 함수는 원하는 때에 생성자를 호출할 수 있다.



### ✓  Companion 객체 팩토리 함수

팩토리 함수를 정의하는 가장 일반적인 방법은 companion 객체를 사용하는 것이다.

```kotlin
class MyLinkedList<T>(
	val head: T,
	val tail: MyLinkedList<T>?
) {
  companion object {
    fun <T> of(vararg elements: T): MyLinkedList<T>? {
      //...
    }
  }
}

//사용
val list = MyLinkedList.of(1, 2)
```

이는 기존의 **자바에서의 정적 팩토리 함수(static factory function)와 유사**하다는 것을 쉽게 알 수 있다.

C++ 같은 언어에서는 이를 **이름을 가진 생성자(Named Constructor Idiom)** 라고 부른다.

코틀린에서는 이러한 접근 방법을 인터페이스에도 구현할 수 있다.

```kotlin
class MyLinkedList<T>(
	val head:T,
	val tail: MyLinkedList<T>?
): MyList<T> {
	//...
}

interface MyList<T>{
	//...
	
	companion object {
		fun <T> of(vararg elements: T): MyLinkedList<T>? {
			//...
		}
	}
}

//사용
val list = MyList.of(1, 2)
```

언뜻 함수의 이름만 보면 무엇을 하는 함수인지 잘 모를 수도 있겠지만, 대부분의 개발자는 자바에서 온 규칙 덕분에 아마 이 이름에 익숙할 것이다.

+ **`from`**: 파라미터를 하나 받고, 같은 타입의 인스턴스 하나를 리턴하는 타입 변환 함수를 나타냄
+ **`of`**: 파라미터를 여러개 받고, 이를 통합해서 인스턴스를 만들어 주는 함수를 나타냄
+ **`valueOf`**: `from` 또는 `of`와 비슷한 기능을 하면서도, 의미를 조금 더 쉽게 읽을 수 있게 이름을 붙인 함수
+ **`instance`** 또는 `getInstance`: 싱글톤으로 인스턴스 하나를 리턴하는 함수
+ **`createInstance`** 또는 `newInstance`: `getInstance`처럼 동작하지만, 싱글톤이 적용되지 않아서, 함수를 호출할 때마다 새로운 인스턴스를 만들어서 리턴
+ **`getType`**: `getInstance`처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을 때 사용하는 이름
+ **`newType`**: `newInstance`처럼 동작하지만, 팩토리 함수가 다른클래스에 있을 때 사용하는 이름

경험이 없는 코틀린 개발자들은 companion 객체 멤버를 단순한 정적 멤버처럼 다루는 경우가 많다.

하지만 companion 객체는 더 많은 기능을 갖고 있다.

예를 들어 인터페이스를 구현할 수 있다던가, 클래스를 상속받을 수도 있다. 또한 추상 companion 객체의 경우 캐싱을 구현하거나, 가짜 객체 생성도 가능하다.



### ✓  확장 팩토리 함수

이미 companion 객체가 존재할 때, 이 객체의 함수처럼 사용할 수 있는 팩토리 함수를 만들어야 할 때가 있다. (예를 들어, 다른 파일에 함수를 만들어야 할때)

이 때는 확장 함수를 활용하면 된다.

```kotlin
interface Tool {
	companion object { /*...*/ }
}
```

해당 인터페이스의 수정이 불가능 할때

```kotlin
fun Tool.Companion.createBigTool( /*...*/ ): BigTool {
	//...
}

//호출
Tool.createBigTool()
```

다음과 같이 확장 함수를 활용하여 호출할 수 있다. (적어도 비어 있는 companion 객체가 필요함)



### ✓  톱레벨 팩토리 함수

객체를 만드는 흔한 방법 중 하나로 톱레벨 팩토리 함수를 이용하는 방법이 있다. (대표적인 예로는  `listOf`, `setOf`, `mapOf`)

톱레벨 함수의 사용은 `List`나 `Map`등을 생각해 보았을 때,`listOf(1, 2, 3)`이 `List.of(1, 2, 3)`보다 훨씬 읽기 쉽기 때문에 객체 생성에 톱레벨 함수를 사용한 것이다.

하지만 톱레벨 함수는 신중하게 사용해야 한다. public 톱레벨 함수의 경우 모든 곳에서 사용할 수 있으므로, IDE가 제공하는 팁을 복잡하게 만드는 단점이 있다.

따라서 혼란을 피하기 위해서는 톱레벨 함수를 만들 때, 꼭 이름을 신중히 생각해서 잘 지정해야 한다.



### ✓  가짜 생성자

가짜 생성자는 생성자처럼 보이고, 생성자처럼 작동한다. 하지만 팩토리 함수와 같은 모든 장점을 갖는 함수이다.

개발자가 진짜 생성자 대신에 가짜 생성자를 만드는 이유는 다음과 같다.

+ **인터페이스를 위한 생성자를 만들고 싶을 때**
+ **reified 타입 아규먼트를 갖게 하고 싶을 때**

이를 제외하면 가짜 생성자는 진짜 생성자처럼 동작해야 한다. 생성자처럼 보여야 하며, 생성자와 같은 동작을 해야 한다.

가짜 생성자를 사용하는 방법은 크게 두 가지로 나뉘는데, 첫 번째로는 코틀린 1.1부터 stdlib에 포함된 `List`와 `MutableList`인터페이스에 대한 가짜생성자를 사용하는 것이다.

두 번째 방법은 invoke 연산자를 갖는 companion 객체를 사용하면, 비슷한 결과를 얻을 수 있지만 거의 사용되지 않으며 추천하지 않는 방법이다.

따라서 가짜 생성자는 톱레벨 함수를 사용하는 것이 좋다. 특수한 상황(reified 타입 파라미터 등으로 생성자를 만들어야 하는 경우)에만 가짜 생성자를 사용하는 것이 좋다.



### ✓  팩토리 클래스 메소드

팩토리 클래스와 관련된 추상 팩토리, 프로토타입 등의 수많은 생성 패턴이 있다. 이러한 패턴들은 각각 다양한 장점을 가진다.

하지만 이러한 패턴의 일부는 코틀린에서는 적합하지 않다.

팩토리 클래스는 클래스의 상태를 가질 수 있다는 특징 때문에 팩토리 함수보다 더 다양한 기능을 갖는다.

팩토리 클래스는 프로퍼티를 가질 수 있으며, 이를 활용하면 다양한 종류로 최적화하고, 다양한 기능을 도입할 수 있다.



## 📖 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라

객체를 정의하고 생성하는 방법을 지정할 때 사용하는 가장 기본적인 방법은 **기본 생성자(primary constructor)를 사용하는 것**이다.

```kotlin
class User(var name: String, var surname: String)
val user = User("Marcin", "Moskala")
```

일반적으로는 이를 활용해서 객체를 만드는 것이 좋다.



### ✓  점층적 생성자 패턴

점층적 생성자 패턴은 자바에서 사용하는 패턴으로 코틀린에서는 일반적으로 **디폴트 아규먼트(default argument)** 를 사용한다.

디폴트 아규먼트가 점층적 생성자보다 좋은 이유는 다음과 같다.

- 파라미터들의 값을 원하는 대로 지정할 수 있다.
- 아규먼트를 원하는 순서로 지정할 수 있다.
- **명시적으로 이름을 붙여서 아규먼트를 지정하므로 의미가 훨씬 더 명확해진다.** **(Named Argument)**



### ✓  빌더 패턴

자바에서는 이름 있는 파라미터와 디폴트 아규먼트를 사용할 수 없다.

따라서 빌더 패턴을 사용한다. 빌더 패턴은 다음과 같은 장점이 있다.

- 파라미터에 이름을 붙일 수 있다.
- 파라미터를 원하는 순서로 지정할 수 있다.
- 디폴트 값을 지정할 수 있다.

하지만 이러한 장점은 코틀린의 디폴트 아규먼트와 이름 있는 파라미터도 가지고 있다.

또한 빌더 패턴보다 이름 있는 파라미터를 사용하는 것이 좋은 이유는 더 있다.

- 더 짧다.
- 더 명확하다.
- 더 사용하기 쉽다.
- 동시성 문제가 없다.
- 팩토리로 사용할 수 있다. (currying을 활용)

**코틀린에서는 빌더 패턴의 사용을 거의 볼 수 없다.** 빌더 패턴은 다음의 경우에만 사용된다.

- 빌더 패턴을 사용하는 다른 언어로 작성된 라이브러리를 그대로 옮길 때
- 디폴트 아규먼트와 DSL을 지원하지 않는 다른 언어에서 쉽게 사용할 수 있게 API를 설계할 때

이를 제외하면, 빌더 패턴 대신에 디폴트 아규먼트를 갖는 기본 생성자 또는 DSL을 사용하는 것이 좋다.



## 📖 복잡한 객체를 생성하기 위한 DSL을 정의하라

코틀린을 활용하면 **DSL(Domain Specific Language)** 을 직접 만들 수 있다.

DSL은 복잡한 객체, 계층 구조를 갖고 있는 객체들을 정의할 때 굉장히 유용하다.

DSL을 만드는 것은 약간 힘든 일이지만, 한 번 만들고 나면 보일러플레이트(boilerplate) 와 복잡성을 숨기면서 개발자의 의도를 명확하게 표현할 수 있다.

```kotlin
body{
	div{
		a("https://kolinlang.org"){
			target = ATarget.blank 
			+"Main site"
		}
	}
	+"Some content"
}
```



### ✓  사용자 정의 DSL 만들기

사용자 정의 DSL을 만드는 방법을 이해하려면, 리시버를 사용하는 함수 타입에 대한 개념을 이해해야 한다.

함수 타임의 몇 가지 예를 살펴보면 다음과 같다.

- `()->Unit` : 아규먼트를 갖지 않고, ` Unit`을 리턴하는 함수
- `(Int)->Unit` : `Int`를 아규먼트로 받고 `Unit`을 리턴하는 함수
- `(Int)->Int` : `Int`를 아규먼트로 받고, `Int`를 리턴하는 함수
- `(Int, Int)->Int` : `Int` 두 개를 아규먼트로 받고, `Int`를 리턴하는 함수
- `(Int)->()->Unit` : `Int`를 아규먼트로 받고, 다른 함수를 리턴하는 함수. 이때 다른 함수는 아규먼트로 아무것도 받지 않고, `Unit`을 리턴
- `(()->Unit)->Unit` : 다른 함수를 아규먼트로 받고, `Unit`을 리턴하는 함수. 이때 다른 함수는 아규먼트로 아무것도 받지 않고 `Unit`을 리턴

함수 타입을 만드는 기본적인 방법은 다음과 같다.

- 람다 표현식
- 익명 함수
- 함수 레퍼런스

예를 들어 다음과 같은 함수가 있다.

```kotlin
fun plus(a: Int, b: Int) = a + b
```

**유사 함수(analogical function)** 은 다음과 같은 방법으로 만든다.

```kotlin
val plus1: (Int, Int)->Int = { a, b -> a + b}
val plus2: (Int, Int)->Int = fun(a, b) = a + b
val plus3: (Int, Int)->Int = ::plus
```

해당 예시에서는 프로퍼티 타입이 지정되어 있으므로, 람다 표현식과 익명 함수의 아규먼트 타입 추론이 가능하다. 반대로 다음과 같이 지정해서 함수의 형태를 추론하게 할 수도 있다.

```kotlin
val plus4 = { a: Int, b: Int -> a + b }
val plus5 = fun(a: Int, b: Int) = a + b
```

함수를 나타내는 타입이 있다면, 확장 함수의 경우는 어떻게 표현할까?

```kotlin
fun Int.myPlus(other: Int) = this + other
```

익명 함수를 만들 때는 일반 함수처럼 만들고, 이름만 빼면 된다.

익명 확장 함수도 이와 같은 방법으로 만들 수 있다.

```kotlin
val myPlus = fun Int.(other: Int) = this + other
```

이 함수의 타입은 확장 함수를 나타내는 **특별한 타입인 리시버를 가진 함수 타입**이다.

일반적인 함수 타입과 비슷하지만, 파라미터 앞에 리시버 타입이 추가되어 있으며, 점 기호로 구분되어 있다.

```kotlin
val myPlus: Int.(Int)->Int = fun Int.(other: Int) = this + other
```

이와 같이 함수는 람다식, 구체적으로 리시버를 가진 람다 표현식을 사용해서 정의할 수 있다.

```kotlin
val myPlus: Int.(Int)->Int = { this + it }
```

리시버를 가진 익명 확장 함수와 람다 표현식은 다음과 같은 방법으로 호출할 수  있다.

- 일반적인 객체처럼 invoke 메소드 사용

- 확장 함수가 아닌 함수처럼 사용

- 일반적인 확장 함수처럼 사용

 ```kotlin
 myPlus.invoke(1, 2)
 myPlus(1, 2)
 1.myPlue(2)
 ```

  이처럼 리시버를 가진 함수 타입의 가장 중요한 특징은 this의 참조 대상을 변경할 수 있다는 것이다.

this는 apply 함수에서 리시버 객체의 메소드와 프로퍼티를 간단하게 참조할 수 있게 해 주기도 한다.

리시버를 가진 함수 타입은 코틀린  DSL을 구성하는 가장 기본적인 블록이다.



### ✓  언제 사용해야 할까?

DSL은 정보를 정의하는 방법을 제공한다. DSL은 여러 종류의 정보를 표현할 수 있지만, 사용자 입장에서는 이 정보가 어떻게 활용되는지 명확하지는 않다.

따라서 DSL은 다음과 같은 것을 표현하는 경우에 유용하다.

- 복잡한 자료 구조
- 계층적인 구조
- 거대한 양의 데이터

DSL 없이 빌더 또는 단순하게 생성자만 활용해도 원하는 모든 것을 표현할 수 있다.

DSL은 많이 사용되는 구조의 반복을 제거할 수 있게 해 준다.

---

* Effective Kotlin - 마르친 모스칼라 지음

