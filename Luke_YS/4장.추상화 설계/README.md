💻 **코드 설계 - 추상화 설계**
=============

**추상화(abstraction)** 는 **OOP(Object-Oriented Programming)** 에서 추상화는 세 가지 주요 개념 중의 하나로, 프로그래밍 세계에서 가장 중요한 개념 중 하나라고 이야기 한다.

컴퓨터 과학에서 **추상화는 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것**을 말한다.



### ✓  프로그래밍에서의 추상화

추상화를 설계한다는 것은 단순하게 모듈 또는 라이브러리로 분리한다는 의미가 아니다. **함수를 정의할 때는 그 구현을 함수 시그니처 뒤에 숨기게 되는데, 이것이 바로 추상화**이다.

보통 강력한 프로그래밍 언어들이 당연히 갖고 있는 기능 중 하나는 **공통 패턴에 이름을 붙여 추상화를 만드는 기능**이다.

예를 들어 함수, 델리게이트, 클래스 등이 대표적인 예시라고 할 수 있다. 이를 활용하면 추상화를 할 수 있다.

추상화는 언어가 표현할 수 있는 표현에 따라서도 조금씩 달라질 수 있다.



### ✓  추상화와 자동차

자동차를 운전할 때는 여러 가지 일이 발생한다. 자동차 내부에서는 엔진, 알터네이터, 서스펜션 등의 여러 가지 요소들이 함께 자동차가 움직일 수 있게 만든다.

운전을 할 때 이러한 요소들을 실시간으로 이해하고 조정해야 한다면, 자동차 운전이 굉장히 힘들 것이다.

하지만 그럴 필요는 없다. **자동차 운전자는 자동차를 조종하는 인터페이스를 사용하는 방법만 알면 된다.**

마찬가지로 프로그래밍에서는 다음과 같은 목적으로 추상화를 사용한다.

+ **복잡성을 숨기기 위해**
+ **코드를 체계화하기 위해**
+ **만드는 사람에게 변화의 자유를 주기 위해**

이번 장에서 제시되는 규칙은 추상적이라 어려울 수 있겠지만 이번 장을 끝내고 나서, 어차피 조금 더 구체적인 OOP 설계를 배울 것이다. 이 때 살펴볼 내용들은 모두 이번 장의 내용을 기반으로 구현될 것이므로, 이번 장의 내용이 굉장히 중요하다.

---



## 📖 함수 내부의 추상화 레벨을 통일하라

개발자의 관점에서 컴퓨터에서 가장 낮은 추상화 계층은 **하드웨어**이다.

개발자는 일반적으로 프로세서를 위한 코드를 작성하므로, 하드웨어 위의 관심 있는 계층은 프로세서 **제어 명령(processor control command)** 이다.

계층을 잘 분리하게 되면 작업하고 있는 계층 아래의 계층은 이미 완성되어 있으므로, 해당 계층만 생각하면 된다는 것이다.

개발자는 일반적으로 특정한 계층에서 작업하며, 가끔 그 위에 추가로 계층을 올려서 사용한다.

계층이 잘 나뉘어져 있어서, 개발자는 해당 계층까지만 알아도 되는 것이다.



### ✓  추상화 레벨

일반적으로 컴퓨터 과학자들은 어떤 계층이 높은 레벨인지 낮은 레벨인지를 구분한다. 높은 레벨로 갈수록 물리 장치로부터 점점 멀어진다.

**높은 레벨일수록 걱정해야 하는 세부적인 내용들이 적다. 하지만 높은 레벨일수록 이러한 단순함을 얻지만, 제어력을 잃는다.**

예를 들어 C언어는 메모리 관리를 직접 할 수 있지만, 자바는 가비지 컬렉터가 자동으로 메모리를 관리해 준다. 따라서 메모리 사용을 최적화하는 것이 굉장히 힘들다.



### ✓  추상화 레벨 통일

컴퓨터 과학과 마찬가지로 코드 역시 함수를 통해 추상화를 계층처럼 나누어서 사용할 수 있다.

함수도 높은 레벨과 낮은 레벨을 구분해서 사용해야 한다는 원칙이 있다. (**추상화 레벨 통일 원칙 - Single Level of Abstraction, SLA**)

함수는 간단해야 한다. 이는 **'함수는 작아야 하며, 최소한의 책임만을 가져야 한다'**라는 일반적인 규칙이다.

또한 어떤 함수가 다른 함수보다 좀 복잡하다면, 일부 부분을 추출해서 추상화하는 것이 좋다.

**모든 추상화 레벨에서 '추상 요소(abstract term)'(메서드 또는 클래스)를 조작한다.**

추가적으로 이런 원칙을 준수해서 함수를 추출한다면, 재사용과 테스트가 쉬워진다.



### ✓  프로그램 아키텍처의 추상 레벨

추상화 계층이라는 개념은 함수보다 높은 레벨에서도 적용할 수 있다. 추상화를 구분하는 이유는 서브시스템의 세부 사항을 숨김으로써 **상호 운영성(interoperability)** 과 플랫폼 독립성을 얻기 위함이다. 이는 문제 중심으로 프로그래밍한다는 의미이다.

이러한 개념은 모듈 시스템을 설계할 때도 중요하다. 모듈을 분리하면 계층 고유의 요소를 숨길 수 있다. 애플리케이션을 만들 때는 입력과 출력을 나타내는 모듈은 낮은 레벨의 모듈이다. 그리고 비즈니스 로직을 나타내는 부분이 높은 레벨의 모듈이다.

계층이 잘 분리된 프로젝트를 계층화가 잘 되었다고 부른다. **계층화가 잘 된 프로젝트를 좋은 프로젝트**라고 부른다.

계층화가 잘 된 프로젝트는 어떤 계층 위치에서 코드를 보아도, **일관적인 관점을 얻을 수 있다.**

끝.

---



## 📖 변화로부터 코드를 보호하려면 추상화를 사용하라

함수와 클래스 등의 추상화로 실질적인 코드를 숨기면, 사용자가 세부 상항을 알지 못해도 괜찮다는 장점이 있다.

그리고 이후에 실질적인 코드를 원하는대로 수정할 수도 있다.

예를 들어 정렬 알고리즘을 함수로 추출하면, 이를 사용하는 코드에 어떠한 영향도 주지 않고, 함수의 성능을 최적화할 수 있다.

이번 아이템에서는 **추상화를 통해 변화로부터 코드를 보호하는 행위가 어떤 자유를 가져오는지 살펴본다.**

세 가지 실제 사례를 살펴보고, 여러 추상화의 균형을 맞추는 방법에 대해 알아본다. 일단 가장 간단한 추상화인 **상수(constant value)** 부터 알아보자.



### ✓  상수

리터럴은 아무것도 설명하지 않는다. 따라서 코드에서 반복적으로 등장할 때 문제가 된다. 이러한 리터럴을 상수 프로퍼티로 변경하면 해당 값에 의미 있는 이름을 붙일 수 있으며, 상수의 값을 변경해야 할 때 훨씬 쉽게 변경할 수 있다. 비밀번호 유효성을 검사하는 간단한 예시를 보자.

```kotlin
fun isPasswordValid(text: String): Boolean {
	if(text.length < 7) return false
	//...
}
```

여기서 숫자 7은 아마도 '비밀전호의 최소 길이'를 나타내겠지만, 이해하는 데 시간이 걸린다. 상수로 빼낸다면 훨씬 쉽게 이해할 수 있을 것이다.

```kotlin
const val MIN_PASSWORD_LENGTH = 7

fun isPasswordValid(text: String): Boolean {
	if(text.length < MIN_PASSWORD_LENGTH) return false
	//...
}
```

이렇게 하면 '비밀번호의 최소 길이'를 변경하기도 쉽다. 함수의 내부 로직을 전혀 이해하지 못해도, 상수의 값만 변경하면 된다.

그래서 **두 번 이상 사용되는 값은 이렇게 상수로 추출**하는 것이 좋다.

상수로 추출하게 되면,

+ **이름을 붙일 수 있고**
+ **나중에 해당 값을 쉽게 변경할 수 있다.**

이는 다른 추상화 방법에서도 적용되는 이야기이다.



### ✓  함수

애플리케이션을 개발하고 있는데, 사용자에게 토스트 메시지를 자주 출력해야 하는 상황이 발생했다고 하자.

기본적으로 다음과 같은 코드를 사용해서 토스트 메시지를 출력한다.

```kotlin
Toast.makeText(this, message, Toast.LENGTH_LONG).show()
```

**이렇게 많이 사용되는 알고리즘은 다음과 같이 간단한 확장 함수로 만들어서 사용할 수 있다.**

```kotlin
fun Context.toast(
	message: String,
	duration: Int = Toast.LENGTH_LONG
) {
	Toast.makeText(this, message, duration).show()
}

//사용
context.toast(message)

//액티비티 또는 컨텍스트의 서브클래스에서 사용할 경우
toast(message)
```

이렇게 일반적인 알고리즘을 추출하면, 토스트를 출력하는 코드를 항상 기억해 두지 않아도 괜찮다. 

또한 이후에 토스트를 출력하는 방법이 변경되어도, 확장 **함수 부분만 수정하면 되므로 유지보수성이 향상**된다.

함수는 매우 단순한 추상화지만, 제한이 많다.

예를 들어 함수는 상태를 유지하지 않는다. 또한 함수 시그니처를 변경하면 프로그램 전체에 큰 영향을 줄 수 있다.

구현을 추상화할 수 있는 더 강력한 방법으로는 클래스가 있다.



### ✓  클래스

```kotlin
class MessageDisplay(val context: Context) {
	fun show(
		message: String,
		duration: MessageLength = MessageLength.LONG
	) {
		val toastDuration = when(duration) {
			SHORT -> Length.SHORT
			LONG -> Length.LONG
		}
		Toast.makeText(context, message, toastDuration).show()
	}
}

enum class MessageLength { SHORT, LONG }

//사용
val messageDisplay = MessageDisplay(context)
messageDisplay.show("Message")
```

클래스가 함수보다 더 강력한 이유는 상태를 가질 수 있으며, 많은 함수를 가질 수 있다는 점 때문이다.

현재 위의 코드에서 클래스의 상태인 context는 기본 생성자를 통해 주입된다.

의존성 주입 프레임워크를 사용하면, 클래스 생성을 위임할 수도 있다.

```kotlin
@Inject lateinit var messageDisplay: MessageDisplay
```

또한 mock 객체를 활용해서 해당 클래스에 의존하는 다른 클래스의 기능을 테스트할 수 있다.

```kotlin
val messageDisplay: MessageDisplay = mock()
```

게다가 메시지를 출력하는 더 다양한 종류의 메서드를 만들 수 있다.

```kotlin
messageDisplay.setChristmasMode(true)
```

이처럼 클래스는 훨씬 더 많은 자유를 보장해 준다. 하지만 여전히 한계가 있다.

예를 들어 클래스가 final이라면, 해당 클래스 타입 아래에 어떤 구현이 있는지 알 수 있다. open 클래스를 활용하면 조금은 더 자유를 얻을 수 있다.

open 클래스는 서브클래스를 대신 제공할 수 있기 때문이다. 더 많은 자유를 얻으려면, 더 추상적이게 만들면 된다.

바로 인터페이스 뒤에 클래스를 숨기는 것이다.



### ✓  인터페이스

코틀린 표준 라이브러리를 읽어보면, 거의 모든 것이 인터페이스로 표현된다는 것을 확인할 수 있다.

+ listOf 함수는 List를 리턴한다. 여기서 List는 인터페이스이다. listOf는 팩토리 메서드라고 할 수 있다.
+ 컬렉션 처리 함수는 Iterable 또는 Collection의 확장 함수로서, List, Map 등을 리턴한다. 이것들은 모두 인터페이스이다.
+ 프로퍼티 위임은 ReadOnlyProperty 또는 ReadWriteProperty 뒤에 숨겨진다. 이것들도 모두 인터페이스이다.

라이브러리를 만드는 사람은 내부 클래스의 가시성을 제한하고, 인터페이스를 통해 이를 노출하는 코드를 많이 사용한다.

인터페이스 뒤에 객체를 숨김으로써 실질적인 구현을 추상화하고, 사용자가 추상화된 것에만 의존하게 만들 수 있는 것이다. 즉 **결합(coupling)** **을 줄일 수 있는 것**이다.

인터페이스 뒤에 클래스를 숨긴다는 것은 다음과 같이 한다는 것을 뜻한다.

```kotlin
interface MessageDipslay {
	fun show(
		message: String,
		duration: MessageLength = LONG
	)
}

class ToastDisplay(val context: Context): MessageDisplay {
	override fun show(
		message: String,
		duration: MessageLength
	) {
		val toastDuration = when(duration) {
			SHORT -> Length.SHORT
			LONG -> Length.LONG
		}
		Toast.makeText(context, message, toastDuration).show()
	}
}

enum class MessageLength { SHORT, LONG }
```

이렇게 구성하면 더 많은 자유를 얻을 수 있다. 이러한 클래스는 태블릿에서 토스트를 출력하게 만들 수도 있고, 스마트폰에서 스낵바를 출력하게 할 수도 있다.

또 다른 장점은 테스트 할 때 **인터페이스 페이킹(faking) 이 클래스 모킹(mocking) 보다도 간단**하므로, **별도의 모킹 라이브러리(mocking library) 를 사용하지 않아도 된다는 것**이다.

마지막으로 선언과 사용이 분리되어 있으므로, ToastDisplay 등의 실제 클래스를 자유롭게 변경할 수 있다.

다만 사용 방법을 변경하려면, MessageDisplay 인터페이스를 변경하고, 이를 구현하는 모든 클래스를 변경해야 한다.



### ✓  ID 만들기(nextId)

프로젝트에서 고유 ID (unique ID)를 사용해야 하는 상황을 가정한다.

가장 간단한 방법은 어떤 정수 값을 계속 증가시키면서, 이를 ID로 활용하는 것이다.

```kotlin
var nextId: Int = 0

//사용
val newId = nextId++
```

그런데 이러한 코드가 많이 사용되면, 약간 위험하다. ID가 생성되는 방식을 변경할 때 문제가 발생하기 때문이다.

+ **이 코드의 ID는 무조건 0부터 시작한다.**
+ **이 코드는 스레드-안전(thread-safe) 하지 않다.**

만약 그래도 이방법을 사용해야 한다면, 일단 이후에 발생할 수 있는 변경으로부터 코드를 보호할 수 있게 함수를 사용해야 한다.

```kotlin
private var nextId: Int = 0
fun getNextId(): Int = nextId++

//사용
var newId = getNextId()
```

이제 ID 생성 방식의 변경으로부터는 보호되지만, ID 타입 변경 등은 대응하지 못한다.

미래의 어느 시점에 ID를 문자열로 변경해야 한다면 어떨까?

만약 그 시점 이전에 ID가 계속 Int로 유지될 거라고 생각해서, 여러 연산들이 타입에 종속적이게 작성되었다면 어떻게 해야 할까?

이를 최대한 방지하려면, 이후에 ID 타입을 쉽게 변경할 수 있게 클래스를 사용하는 것이 좋다.

```kotlin
data class Id(private val id: Int)

private var nextId: Int = 0
fun getNextId(): Id = Id(nextId++)
```

더 많은 추상화는 더 많은 자유를 주지만, 이를 정의하고, 사용하고, 이해하는 것이 조금 어려워졌다.



### ✓  추상화의 문제

큰 프로젝트에서는 잘 모듈화를 해야한다. 추상화 비용도 발생하기 때문에 극단적으로 모든 것을 추상화해서는 안된다.,

거의 무한하게 추상화할 수 있지만, 어느 순간부터 득보다 실이 많아질 것이다.



### ✓  어떻게 균형을 맞춰야 할까?

모든 추상화는 자유를 주지만, 코드가 어떻게 돌아가는 것인지 이해하기 어렵게 만든다. **극단적인 것은 언제나 좋지 않다.**

최상의 답은 언제나 그 사이 어딘가에 있다. 정확한 위치는 다음과 같은 요소들에 따라서 달라질 수 있다.

+ **팀의 크기**
+ **팀의 경험**
+ **프로젝트의 크기**
+ **특징 세트(feature set)**
+ **도메인 지식**

따라서 프로젝트에 따라서 균형이 다를 수 있다. 적절한 균형을 찾는 것은 거의 감각에 의존해야 하는 예술에 가깝다.

수천 시간까지는 아니더라도, 수백 시간 이상의 경험이 있어야 할 수 있는 일이다. 그래도 사용할 수 있는 몇 가지 규칙을 정리해 보면 다음과 같다.

+ 많은 개발자가 참여하는 프로젝트는 이후에 객체 생성과 사용 방법을 변경하기 어렵다. 따라서 추상화 방법을 사용하는 것이 좋다. 최대한 모듈과 부분을 분리하는 것이 좋다.
+ 의존성 주입 프레임워크를 사용하면, 생성이 얼마나 복잡한지는 신경 쓰지 않아도 된다.
+ 테스트를 하거나, 다른 애플리케이션을 기반으로 새로운 애플리케이션을 만든다면 추상화를 사용하는 것이 좋다.
+ 프로젝트가 작고 실험적이라면, 추상화를 하지 않고도 직접 변경해도 괜찮다.

항상 무언가 변화할 수 있다고 생각하는 것이 좋다. 예를 들어 토스트 출력 API가 변경될 가능성은 적지만, 메시지를 출력하는 방법을 변경해야 할 가능성은 충분히 있다. 이후에 더 일반적인 메커니즘이 필요할 가능성이 있는지, 플랫폼 독집적인 메커니즘이 필요할 수 있는지, 이러한 확률이 얼마나 되는지 등은 여러 가지 경험을 해 보면 어느정도 알 수 있게 된다.



### ✓  정리

추상화는 단순하게 중복성을 제거해서 코드를 구성하기 위한 것이 아니다. 추상화는 코드를 변경해야 할 때 도움이 된다.

따라서 추상화를 사용하는 것은 굉장히 어렵지만, 이를 배우고 이해해야 한다.

다만 추상적인 구조를 사용하면, 결과를 이해하기 어렵다. **추상화를 사용할 때의 장점과 단점을 모두 이해하고, 프로젝트 내에서 그 균형을 찾아야 한다.**

끝.

---

## 📖 API 안정성을 확인하라

프로그래밍에서는 안정적이고 **최대한 표준적인 API(Application Programming Interface)** 를 선호한다. 주요 이유는 다음과 같다.

+ API가 변경되고, 개발자가 이를 업데이트했다면, 여러 코드를 수동으로 업데이트 해야한다. 많은 요소가 이 API에 의존하고 있다면 이는 큰 문제가 된다.
+ 사용자가 새로운 API를 배워야 한다. 새로 배운다는 것은 꽤 힘들고 고통스러운 일이므로, 많은 사람이 이를 피한다. 하지만 새로 배우지 않으면, 오래된 지식 때문에 보안 문제가 발생할 수 있다. 따라서 처음부터 안정적이지 않은 모듈을 많이 공부하는 것보다는 안정적인 모듈부터 공부해 두는 것이 좋다.

하지만 처음부터 좋은 API를 한번에 설계할 수는 없다. API 제작자는 이를 계속해서 개선하기 위해서 변경을 한다. 따라서 우리는 계속해서 API를 안정적으로 유지하기 위한 의견을 제시해서 균형을 맞춰야 한다.

일단 간단한 방법은 작성자가 'API' 또는 'API의 일부'가 불안정하다면, 이를 명확하게 알려주어야 한다.

일반적으로 버전을 활용해서 라이브러리와 모듈의 안정성을 나타낸다.

일반적으로 많은 버저닝 시스템 가운데 **시멘틱 버저닝(Semantic Versioning, SemVer)** 을 사용한다. (0.y.z)

+ MAJOR 버전: 호환되지 않는 수준의 API 변경
+ MINOR 버전: 이전 변경과 호환되는 기능을 추가
+ PATCH 버전: 간단한 버그 수정



### ✓  정리

사용자는 API의 안정성에 대해 알아야 한다. 안정적인 API를 사용하는 것이 좋다. 다만 안정적이라고 생각했던 API에 예상하지 못한 변경이 일어났다면, 가장 나쁜 상황이다.

이러한 변경은 수많은 사람들에게 고통을 줄 수 있따. 따라서 모듈과 라이브러리를 만드는 사람과 이를 사용하는 사람들 사이에 커뮤니케이션이 중요하다.

커뮤니케이션은 버전 이름, 문서, 어노테이션 등을 통해 할 수 있다. 또한 안정적인 API에 변경을 가할 때는 사용자가 적응할 충분한 시간을 줘야 한다.

끝.

---

## 📖 외부 API를 랩(wrap)하여 사용하라

API 설계자가 안전하지 않다고 하거나 API 설계자가 안전하다고 해도 우리가 그것을 제대로 신뢰할 수 없다면, 해당 API는 불안정한 것이다.

이러한 불안정한 API를 과도하게 사용하는 것은 굉장히 위험하다. 어쩔 수없이 이런 API를 활용해야 한다면, 최대한 이러한 API를 로직과 직접 결합시키지 않는 것이 좋다.

그래서 많은 프로젝트가 잠재적으로 불안정하다고 판단되는 **외부 라이브러리 API를 랩(wrap) 해서 사용**한다.

랩해서 사용하는 경우 다음과 같은 자유와 안정성을 얻을 수 있다.

+ 문제가 있다면 래퍼(wrapper) 만 변경하면 되므로, API 변경에 쉽게 대응할 수 있다.
+ 프로젝트의 스타일에 맞춰서 API의 형태를 조정할 수 있다.
+ 특정 라이브러리에서 문제가 발생하면, 래퍼를 수정해서 다른 라이브러리를 사용하도록 코드를 쉽게 변경할 수 있다.
+ 필요한 경우 쉽게 동작을 추가하거나 수정할 수 있다.

단점으로는 다음과 같은 것들이 있다.

+ 래퍼를 따로 정의해야 한다.
+ 다른 개발자가 프로젝트를 다룰 때, 어떤 래퍼들이 있는지 따로 확인해야 한다.
+ 래퍼들은 프로젝트 내부에서만 유효하므로, 문제가 생겨도 질문할 수 없다.

**장점과 단점을 모두 이해한 후 랩할 API를 결정해야 한다.** 라이브러리가 얼마나 안정적인지 확인할 수 있는 가장 기본적인 휴리스틱은 **버전 번호**와 **사용자 수**이다.

일반적으로 **라이브러리 사용자가 많을수록 안정적**이다. 사용자가 많으면, 제작자가 프로젝트에 작은 변화를 가할 때도 굉장히 신중하게 할 것이다.

반대로 인기가 없고 새로 만들어진 라이브러리는 위험할 수 있다.

끝.

---



## 📖 요소의 가시성을 최소화하라

API를 설계할 때 가능한 한 간결한 API를 선호하는 데는 여러 가지 이유가 있다.

- 작은 인터페이스는 배우기 쉽고 유지하기 쉽다.
- 변경을 가할 때는 기존의 것을 숨기는 것보다 새로운 것을 노출하는 것이 쉽다. 
- 클래스의 상태를 나타내는 프로퍼티를 외부에서 변경할 수 있다면, 클래스는 자신의 상태를 보장할 수 있다.
- 서로서로 의존하는 프로퍼티가 있을 때는 객체 상태를 보호하는 것이 더 중요해진다.

가시성이 제한될수록 클래스의 **변경을 쉽게 추적**할 수 있으며, **프로퍼티의 상태를 더 쉽게 이해**할 수 있다.

이는 **동시성(concurrency)을 처리할 때 중요**하다. 많은 것을 제한할수록 명별 프로그래밍에서의 안전을 확보할 수 있다.



### ✓  가시성 한정자 사용하기

내부적인 변경 없이 작은 인터페이스를 유지하고 싶다면, **가시성(visibility)을 제한**하면 된다.

기본적으로 클래스와 요소를 외부에 노출할 필요가  없다면, 가시성을 제한해서 외부에서 접근할 수 없게 만드는 것이 좋다.

가시성 제한은 **가시성 한정자(visibilitymodifier)을 활용해서 구현**한다.

- Public(디폴트): 어디에서나 볼 수 있음
- Private: 클래스 내부에서만 볼 수 있음
- Protected: 클래스와 서브클래스 내부에서만 볼 수 있음
- Internal: 모듈 내부에서만 볼 수 있음

톱레벨 요소에는 세 가지 가시성 한정자를 사용할 수 있다.

- Public(디폴트): 어디에서나 볼 수 있음
- Private: 같은 파일 내부에서만 볼 수 있음
- Internal: 모듈 내부에서만 볼 수 있음



### ✓  정리

요소의 가시성은 최대한 제한적인 것이 좋다. 보이는 요소들은 모두 public API로서 사용되며, 다음과 같은 이유로 최대한 단순한 것이 좋다.

- **인터페이스가 작을수록 공부하고 유지하는 것이 쉽다.**
- **최대한 제한이 되어 있어야 변경하기 쉽다.**
- **클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임질 수 있다.**
- **가시성이 제한되면 API의 변경을 쉽게 추적할 수 있다.**

---



## 📖 문서로 규약을 정의하라

일반적인 문제는 행위가 문서화되지 않고, 요소의 이름이 명확하지 않다면 이를 사용하는 사용자는 우리가 만들려고 했던 추상화 목표가 아닌, 현재 구현에만 의존하게 된다는 것이다.

이러한문제는 예상되는 행위를 문서로 설명함으로써 해결할 수 있다.



### ✓  규약

어떤 행위를 설명하면 사용자는 이를 일종의 약속으로 취급하며, 이를 기반으로 스스로 자유롭게 생각하던 예측을 조정한다.

이처럼 예측되는 행위를 **요소의 규약(contract of an element)** 이라고 부른다.

규약이 확실하게 정의되어 있다면, 클래스를 만든 사람은 클래스가 어떻게 사용될지 걱정하지 않아도 되고, 클래스를 사용하는 사람은 내부적으로 어떻게 구현되어 있는지를 걱정하지 않아도 된다.



### ✓  규약 정의하기

규약의 정의는 어떻게 할까?

- **이름**: 일반적인 개념과 관련된 메서드는 이름만으로 동작을 예측할 수 있다.
- **주석과 문서**: 필요한 모든 규약을 적을 수 있는 강력한 방법이다.
- **타입**: 타입은 객체에 대한 많은 것을 알려준다. (리턴 / 아규먼트)



### ✓  주석을 써야할까?

언제나 극단적인 것이 좋진 않다. **현대의 주석은 문서를 자동 생성하는 데 많이 사용**된다.

너무 많은 주석은 노이즈일 뿐이다. **함수 이름과 파라미터만으로 정확하게 표현되는 요소에는 따로 주석을 넣지 않는 것이 좋다.**



### ✓  KDoc

주석으로 함수를 문서화할 때 사용되는 공식적인 형식을 KDoc라고 부른다.

모든 KDoc 주석은 `/**` 로 시작해서 `*/`로 끝난다. 또한 이사이의 모든 줄은 일반적으로 `*`로 시작한다.

- 첫 번째 부분은 요소에 대한 요약 설명(summary description)
- 두 번째 부분은 상세 설명
- 이어지는 모든 줄은 태그 (태그는 추가적인 설명을 위해 사용)

사용하는 태그는 다음과 같다.

- `@param <name>`: '함수 파라미터' 또는 '클래스, 프로퍼티, 함수 타입 파라미터'를 문서화한다.
- `@return:` 함수의 리턴 값을 문서화 한다.
- `@constructor`: 클래스의 기본 생성자를 문서화한다.
- `@receiver`: 확장 함수의 리시버를 문서화한다.
- `@property <name>`: 명확한 이름을 갖고 있는 클래스의 프로퍼티를문서화 한다.
- `@throws <class>`, `@exception <class>`: 메서드 내부에서 발생할 수 있는 예외를 문서화한다.
- `@sample <identifier>`: 정규화된 형식 이름(specified qualified name)을 사용해서 함수의 사용 예를 문서화한다. 
- `@see <identifier>`: 특정한 클래스 또는 메서드에 대한 링크를 추가한다.
- `@author`: 요소의 작성자를 지정한다.
- `@since`: 요소에 대한 버전을 지정한다.
- `@supress`: 이를 지정하면 만들어지는 문서에서 해당 요소가 제외된다.

모든 것을 설명할 필요는 없다. 짧으면서 명확하지 않은 부분을 자세하게 설명하는 문서가 좋은 문서이다.



### ✓  타입 시스템과 예측

클래스가 어떤 동작을 할 것이라 예측되면, 그 서브클래스도 이를 보정해야 한다.

이를 **리스코프 치환 원칙(Liskov substitution principle)** 이라고 부른다.

기본적으로 'S가 T의 서브타입이라면, 별도의 변경이 없이도 T 타입 객체를 S 타입의 객체로 대체할 수 있어야 한다'라고 이야기한다.

그래서 클래스가 어떻게 동작할 거라는 예측 자체에 문제가 있다면, 이 클래스와 관련된 다양한 상속 문제가 발생할 수 있다.

사용자가 클래스의 동작을 확실하게 예측할 수 있게 하려면, 공개 함수에 대한 규약을 잘 지정해야 한다.

예를 들어 다음과 같은 인터페이스를 활용하면, 자동차에 대한 규약을 좀 더 잘 지정할 수 있다.

```kotlin
interface car {
	fun setWheelPosition(angle: Float)
	fun setBreakPedal(pressure: Double)
	fun setGasPedal(pressure: Double)
}

class GasolineCar: Car {
	//...
}

class GasCar: Car {
	//...
}

class ElectricCar: Car {
	//...
}
```

이러한 인터페이스는 모두 문서를 통해서 전달할 수 있다.

```kotlin
interface car {
  
  /** 자동차의 방향을 변경합니다.
  *
  * ~~~설명~~~
  */
	fun setWheelPosition(angle: Float)
  
  /** 자동차의 속도가 0이 될 때까지 감속한다.
  *
  * ~~~설명~~~
  */
	fun setBreakPedal(pressure: Double)
  
  /** 최대 속도까지 차량을 가속한다.
  *
  * ~~~설명~~~
  */
	fun setGasPedal(pressure: Double)
}

class GasolineCar: Car {
	//...
}

class GasCar: Car {
	//...
}

class ElectricCar: Car {
	//...
}
```

이를 기반으로 사용자는 해당 클래스에 대한 예측을 쉽게 할 수 있다. 이러한 설명과 규약은 인터페이스를 유용하게 만든다. 



### ✓  조금씩 달라지는 세부 사항

구현의 세부적인 내용은 항상 조금씩 다르다.

프로그래밍 언어에서도 구현의 세부 사항은 조금씩 달라진다.

**언어는 어떤 식으로 작동해도 괜찮지만, 좋은 방식들을 기억하고 이를 적용해서 사용하는 것이 좋다.**

구현의 세부사항은 항상 달라질 수 있지만, 최대한 많이 보호하는 것이 좋다.

일반적으로 **캡슐화를 통해서 이를 보호**한다. 캡슐화는 '허용하는 범위'를 지정하는 데 도움을 주는 도구이다.

**캡슐화가 많이 적용될수록, 사용자가 구현에 신경을 많이 쓸 필요가  없어지므로, 더 많은 자유를 갖게 된다.**

---



## 📖 추상화 규약을 지켜라

**규약은 보증(warranty)** 과 같다.

스마트폰을 그냥 사용했다면 AS를 받을 수 있지만, 스마트폰을 뜯거나 해킹했다면 AS를 받을 수 없다.

코드도 마찬가지이다. 규약을 위반하면, 코드가 작동을 멈췄을 때 문제가 된다.



### ✓  상속된 규약

클래스를 상속하거나, 다른 라이브러리의 인터페이스를 구현할 때는 규약을 반드시 지켜야 한다.

예를 들어 equals and hashCod 메서드를 가진 Any 클래스를 상속받는다. 이러한 메서드는 모두 우리가 반드시 존중하고 지켜야 하는 규약을 갖는다.

```kotlin
class Id(val id: Int) {
	override fun equals(other: Any?) =
		other is Id &&other.id == id
}

val set = mutableSetOf(Id(1))
set.add(Id(1))
set.add(Id(1))
print(set.size)	//3
```

---

* Effective Kotlin - 마르친 모스칼라 지음
