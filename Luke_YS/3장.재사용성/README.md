💻 **코드 설계 - 재사용성**
=============

우리가 평소에 코드를 짜면서 보는 수많은 함수들과 라이브러리들이 과연 어떤식으로 작동하는지 궁금한적 있나?

또는 안드로이드 뷰를 만들어주는 함수들, 백엔드 개발에 사용되는 HTTP와 HTTPS 프로토콜, 로직을 짜는데 필요한 정렬 알고리즘 등 사실 내부에 구현된 자세한 내용을 몰라도 우리가 원하는 코드를 구현하는데 아무 무리가 없다.

누군가 한번 이를 만들어 놓으면 필요하거나 원할 때 언제든 사용할 수 있다.

이것이 바로 프로그래밍 언어의 핵심 특징인 **재사용성 (reusability)** 이다.

재사용성은 큰 힘을 가지고 있지만, 사실 **재사용성을 고려하는 일은 생각보다 어렵고 다양한 오류를 발생시킬 수 있다.**

이번 챕터에서는 이러한 재사용성에 대해 알아볼 예정이다.

---



## 📖 knowledge를 반복하여 사용하지 말라

### "프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다."

[실용주의 프로그래머] 라는 책에서는 다음과 같은 내용을 **"Don't Repeat Yourself" (Rule's of DRY)** 라고 표현한다.

또 다른 표현으로는 **WET 안티패턴 (Write Everything Twice)**, **SSOT (Single Source of Truth)** 라고 하기도 한다.



### ✓  Knowledge

프로그래밍에서 knowledge는 넓은 의미로 **'의도적인 정보'**를 뜻한다.

알고리즘의 작동 방식, UI의 형태, 우리가 원하는 결과 등이 모두 '의도적인 정보'이며, knowledge라고 할 수 있다.

우리가 개발하는 프로그램에서 중요한 knowledge를 크게 두 가지 뽑는다면, 다음과 같다.

+ **로직 (logic)**: 프로그램이 어떤 식으로 동작하는지와 프로그램이 어떻게 보이는지
+ **공통 알고리즘 (common algorithm)**: 원하는 동작을 하기 위한 알고리즘

이 둘의 **가장 큰 차이점은 시간에 따른 변화**이다. 비즈니스 로직은 시간이 지나면서 계속해서 변하지만, 공통 알고리즘은 한 번 정의된 이후네는 크게 변하지 않는다.



### ✓  모든 것은 변화한다

프로그래밍에서 **유일하게 유지되는 것은 '변화한다는 속성**'이라는 말이 있다.

변화는 우리가 예상하지 못한 곳에서 일어난다. 특히나 UI 디자인과 기술 표준 등은 훨씬 빠르게 변화한다. 고객에 대한 이해도 매일매일 변화한다. 이처럼 우리 프로젝트의 knowledge도 계속해서 변화한다. 변화하는 몇 가지 이유를 적어보면 다음과 같다.

+ 회사가 사용자의 요구 또는 습관을 더 많이 알게 되었다.
+ 디자인 표준이 변화했다.
+ 플랫폼, 라이브러리, 도구 등이 변화해서 이에 대응해야 한다.

오늘날 대부분의 프로젝트는 몇 달마다 요구 사항과 내부적인 구조를 계속해서 변경한다. 모든 것은 변화하고, 우리는 이에 대비해야 한다.

변화할 때 가장 큰 적은 knowledge가 반복되어 있는 부분이다.

**그렇다면 프로그램 내부에서 여러 부분에 반복되어 있는 코드를 변경하려면 어떻게 해야 할까?**

가장 간단하게는 **모두 찾고 고치면 된다.** 하지만 이런 과정은 무엇보다 귀찮고 실수가 나오기 마련이다.

**knowledge의 반복은 확장성(scalable) 을 막고, 쉽게 깨지게(fragile) 만든다.**

다행히도 개발자는 knowledge의 반복을 줄일 수 있는 도구와 기능들을 활용할 수 있다.

여러 종류의 추상화를 표현할 수 있는 수많은 솔루션이 있으며, 이를 활용하면 반복을 줄일 수 있다.



### ✓  언제 코드를 반복해도 될까?

그렇다면 반대로 추출을 통해 knowledge 반복을 줄이면 안 되는 상황은 어떤 상황일까?

얼핏보면 knowledge의 반복처럼 보이지만, 실질적으로 다른 knowledge를 나타내므로 추출하면 안 되는 부분이 존재한다.

**신중하지 못한 추출은 변경을 더 어렵게 만들고, 구성을 읽을 때도 더욱 어려울 수 있다.**

코드를 추출하는 이뉴는 변경을 쉽게 만들기 위함이므로, **비즈니스 규칙이 다른 곳(source)** 에서 왔는지 확인하는 방법이 있다.

다른 곳에서 왔다면, 변경될 가능성이 높다. 잘못된 코드 추출로부터 우리를 보호할 수 있는 규칙도 있다.

바로 **단일 책임 원칙(Single Responsibility Principal, SRP)** 입니다.



### ✓  단일 책임 원칙

**단일 책임 원칙이란 '클래스를 변경하는 이유는 단 한 가지여야 한다.'** 라는 의미이다.

'두 액터가 같은 클래스를 변경하는 일은 없어햐 한다.' 이 때 액터는 변화를 만들어내는 존재를 의미한다.

액터는 서로의 업무와 분야에 대해서 잘 모르는 개발자들로 비유된다. 이러한 개발자들이 같은 코드 변경하는 것은 굉장히 위험한 일이다.

다음과 같은 **단일 책임 원칙을 사전에 방지하기 위해**서는 다음을 지켜야 한다.

+ 두 부서에서 모두 사용하는 일반적인 **public 함수로 헬퍼 함수를 만든다.** 공통 부분은 두 부서에서 모두 사용하므로, 이를 함부로 수정해서는 안되게 규약을 정한다.
+ 헬퍼 함수를 각각의 **부서 모듈에 따라 2개** 만든다.

어떤 선택지를 사용해도 헬퍼 함수를 사용하기에 안전하다.

또한 단일 책임 원칙은 우리에게 두 가지의 사실을 알려준다.

+ 서로 다른 곳에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많다. 따라서 **비슷한 처리를 하더라도 다른 knowledge로 취급하는 것**이 좋다.
+ **다른 knowledge는 분리해 두는 것이 좋다.** 그렇지 않으면, 재사용해서는 안 되는 부분을 재사용하려는 유혹이 발생할 수 있다.



### ✓  챕터 정리

여러 요소에 비슷한 부분이 있는 경우, 변경이 필요할 때 실수가 발생할 수 있다. 이런 부분은 추출하는 것이 좋다.

의도하지 않은 수정을 피하려면 또는 다른 곳에서 조작하는 부분이 있다면, 분리해서 사용하는 것이 좋다.

그렇다고해서 극단적인 것이 항상 좋은 것은 아니다. 균형이 중요하다.

끝.

---



## 📖 일반적인 알고리즘을 반복해서 구현하지 말라

많은 개발자들은 같은 알고리즘을 여러 번 반복해서 구현한다.

하지만 stdlib 같이 이미 존재하는 알고리즘 등을 활용하면, 단순하게 코드가 짧아진다는 것 이외에도 다양한 장점이 있다.

+ 코드 작성 속도가 빨라진다.
+ 구현을 따로 읽지 않아도, 함수의 이름 등만 보고 무엇을 하는지 확실하게 알 수 있다.
+ 직접 구현할 때 발생할 수 있는 실수를 줄일 수 있다.
+ 제작자들이 한 번만 최적화하면, 이러한 함수를 활용하는 모든 곳이 최적화의 혜택을 받을 수 있다.



### ✓  표준 라이브러리 살펴보기

일반적인 알고리즘은 대부분 이미 다른 사람들이 정의해 놓았다. 그중에서 가장 대표적인 라이브러리는 바로 표준 라이브러리인 stdlib이다.

stdlib의 함수들을 하나하나 살펴보는 것은 굉장히 어려울 수 있지만, 그럴만한 가치가 있는 일이다.

만약 이를 자세히 살펴보지 않으면, 계속해서 같은 함수를 여러 번 만들게 될 것이다.

**따라서 라이브러리를 사용할 때는 사용하려는 함수에 대해 명확하게 알고 최적의 함수를 찾아 사용하는 것이 중요하다.**



### ✓  나만의 유틸리티 구현하기

상황에 따라서 표준 라이브러리에 없는 알고리즘이 필요할 수도 있다. 

예를 들어 컬렉션에 있는 모든 숫자의 곱을 계산하는 라이브러리가 필요하다면 어떻게 해야할까?

이는 널리 알려 추상화이므로 **범용 유틸리티 함수(univeral utility function) 으로 정의**하는 것이 좋다.

```kotlin
fun Iterable<Int>.product() =
	fold(1) { acc, i -> acc * i }
```

여러번 사용되지 않는다고 해도 이처럼 만드는 것이 좋다.

이는 잘 알려진 수학적 개념이고, product라는 이름이 숫자를 곱할 거라는 것은 대부분의 개발자들이 예측할 수 있기 때문이다.

하지만 동일한 결과를 얻는 함수를 여러 번 만드는 것은 잘못된 일이다. 

**모든 함수는 테스트되어야 하고, 기억되어야 하며, 유지보수되어야 한다.**

따라서 함수를 만들 때는 이러한 비용이 들어갈 수 있다는 것을 전제해야 한다.

**필요없는 함수를 중복해서 만들지 않게, 기존에 관련된 함수가 있는지 탐색하는 과정이 필요하다.**

사실 위의 product 함수도 kotlin의 stdlib 라이브러리 안에서 확장 함수로 구현이 되어 있다.

많이 사용되는 알고리즘을 추출하는 방법으로는 톱레벨 함수, 프로퍼티 위임, 클래스 등이 있다.

확장 함수는 이러한 방법들과 비교해서, 다음과 같은 장점을 갖는다.

+ **함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋다.** 특히 부가 작용(side-effect) 이 없는 경우에는 더 좋다.
+ 톱레벨 함수와 비교해서, **확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한**할 수 있으므로 좋다.
+ 수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 **확장 리시버로 사용하는 것**이 가독성 측면에서 좋다.
+ 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능 등으로 제안이 이루어지므로 **쉽게 찾을 수 있다.**



### ✓  챕터 정리

일반적인 알고리즘을 반복해서 만들지 말자. 대부분은 이미 stdlib에 이미 정의되어 있을 가능성이 높다. 따라서 stdlib를 더 공부해 두자.

특정 알고리즘을 반복해서 사용해야 하는 경우에는 **프로젝트 내부에 직접 정의**하자. 일반적으로 이런 알고리즘은 **확장 함수를 사용**해서 정의하자.

끝.

---



## 📖 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라

코틀린은 코드 재사용과 관련해서 **프로퍼티 위임**이라는 새로운 기능을 제공한다.

프로퍼티 위임을 사용하면 일반적인 프로퍼티의 행위를 추출해서 재사용할 수 있다.

대표적인 예로 **지연 프로퍼티**가 있다. **처음 사용하는 요청이 들어올 때 초기화되는 프로퍼티를 의미한다.**

자바의 경우에는 이를 구현하려면 굉장히 복잡한 구현이 필요하지만, 코틀린에서는 프로퍼티 위임을 활용해 간단하게 구현할 수 있다.

```kotlin
val value by laze { createValue() }
```

지연 프로퍼티 이외에도 변화가 있을 때 감지하는 observable 패턴을 쉽게 만들 수 있다.

```kotlin
var items: List<Item> by
	Delegates.observable(listOf()) { _, _, _ ->
		notifyDataSetChanged()	
}

var key: String? by
	Delegates.observable(null) { _, old, new ->
 		Log.e("key changed from $old to $new")                            
}
```

lazy와 observable 델리게이터는 사실 언어적인 관점으로 보았을 때, 그렇게 특별한 것은 아니다.

일반적으로 프로퍼티 위임 메커니즘을 활용하면, 다양한 패턴들을 만들 수 있다. 좋은 예로 **뷰, 리소스 바인딩, 의존성 주입, 데이터 바인딩** 등이 있다.

이와 같은 패턴들을 자바에서 사용하려면 다양한 어노테이션을 많이 활용해야 한다.

하지만 코틀린은 프로퍼티 위임을 사용해서 간단하고 type-safe하게 구현할 수 있다.

```kotlin
var token: String? by LoggingProperty(null)
var attempts: Int by LoggingProperty(0)

private class LoggingProperty<T>(var value: T) {
	operator fun getValue(
		thisRef: Any?,
		prop: KProperty<*>
	): T {
		print("${prop.name} returned value $value")
		return value
	}
	
	operator fun setValue(
		thisRef: Any?,
		prop: KProperty<*>,
		newValue: T
	) {
		val name = prop.name
		print("$name changed from $value to $newValue")
		value = newValue
	}
}
```

**프로퍼티 위임은 다른 객체의 메서드를 활용해서 프로퍼티의 접근자(게터와 세터) 를 만드는 방식**이다.

이때 **게터는 getValue, 세터는 setValue 함수를 사용**해서 만들어야 한다. 

객체를 만든 뒤에는 **by 키워드를 사용**해서, getValue와 setValue를 정의한 클래스와 연결해 주면 된다.

프로퍼티 위임이 어떻게 동작하는지 이해하려면, by가 어떻게 컴파일되는지 보는 것이 좋다.

**getValue와 setValue는 단순하게 값만 처리하게 바뀌는 것이 아니라, 컨텍스트(this) 와 프로퍼티 레퍼런스의 경계도 함께 사용하는 형태로 바뀐다.**

또한 컨텍스트는 함수가 **어떤 위치에서 사용되는지와 관련된 정보를 제공**해 준다.

이는 **getValue와 setValue 메서드가 여러 개 있어도 문제 없다**는 뜻이다. (컨텍스트를 활용하므로 상황에 따라 적절한 메서드가 선택된다.)

코틀린 stdlib에서 굉장히 범용적으로 사용되는 패턴들에 대한 프로퍼티 델리게이터들을 알아 두면 좋다.

+ lazy
+ Delegates.observable
+ Delegates.vetoable
+ Delegates.notNull



### ✓  챕터 정리

**프로퍼티 델리게이트는 프로퍼티와 관련된 다양한 조작을 할 수 있으며, 컨텍스트와 관련된 대부분의 정보를 갖는다.**

이러한 특징으로 인해 다양한 **프로퍼티의 동작을 추출해 재사용**할 수 있다.

끝.

---



## 📖 일반적인 알고리즘을 구현할 때 제네릭을 사용하라

아규먼트로 함수에 값을 전달할 수 있는 것처럼, 타입 아규먼트를 사용하면 함수에 타입을 전달할 수 있다.

이를 **제네릭 함수(generic function)** 이라고 부른다.

대표적인 예로는 stdlib의 filter 함수가 있다.

타입 파라미터는 타입에 대한 정보를 제공하여 **컴파일러가 타입을 조금이라도 더 정확하게 추측할 수 있게 해준다.** 

따라서 프로그램이 조금 더 안전해지고, 개발자는 프로그래밍이 편해진다.

제네릭은 기본적으로 List<String> 또는 Set<User> 처럼 구체적인 타입으로 컬렉션을 만들 수 있게 클래스와 인터페이스에 도입된 기능이다.

이와 같은 기능은 정적 타입 프로그래밍 언어에서는 굉장히 유용하게 활용된다.

코틀린은 강력한 제네릭 기능을 갖고 있지만, 조금 복잡해서 이해하기 어렵다.



### ✓  제네릭 제한

타입 파리미터의 중요한 기능 중 하나는 **구체적인 타입의 서브타입만 사용하게 타입을 제한**하는 것이다. 

예를 들어 T를 Iterable<Int> 의 서브타입으로 제한하면, T 타입을 기반으로 반복 처리가 가능하고, 반복 처리 때 사용되는 객체가 Int라는 것을 알 수 있다.

또한 Comparable<T> 로 제한하면, 해당 타입을 비교할 수 있다는 것을 알 수 있다.



### ✓  챕터 정리

코틀린 자료형 시스템에서 타입 파라미터는 굉장히 중요한 부분이다. 일반적으로 이를 사용해서 **type-safe 제네릭 알고리즘과 제네릭 객체를 구현**한다.

타입 파라미터는 **구체 자료형(concrete type)** 의 서브타입을 제한할 수 있다. 이렇게 하면 특정 자료형이 제공하는 메서드를 안전하게 사용할 수 있다.

---



## 📖 타입 파라미터의 섀도잉을 피하라

```kotlin
class Forest(val name: String) {
	fun addTree(name: String) {
		//...
	}
}
```

이러한 코드와 같이 프로퍼티와 파라미터가 같은 이름을 가질 수 있다. 이렇게 되면 지역 파라미터가 외부 스코프에 있는 프로퍼티를 가린다.

이것을 **섀도잉(shadowing)** 이라고 부른다.

이러한 **섀도잉 현상은 클래스 타입 파라미터와 함수 타입 파라미터 사이에서도 발생**한다.

```kotlin
interface Tree
class Birch: Tree
class Spruce: Tree

class Forest<T: Tree> {
	fun <T: Tree> addTree(tree: T) {
		//...
	}
}
```

이렇게 코드를 작성하면, Forest와 addTree 타입 파라미터가 독립적으로 동작한다.

이것은 심각한 문제가 될 수 있으며, 개발자가 스스로 문제를 찾아내기도 힘들다.

따라서 이럴 때는 addTree가 **클래스 타입 파라미터인 T를 사용하게 하는 것이 좋다.**

```kotlin
class Forest<T: Tree> {
	fun addTree(tree: T) {
		//...
	}
}

//usage
val forest = Forest<Birch>()
forest.addTree(Birch())
forest.addTree(Spruce())	//ERROR, type mismatch
```

만약 **독립적인 타입 파라미터를 의도했다면, 이름을 아예 다르게 다는 것**이 좋다.

참고로, 다음 코드처럼 타입 파라미터를 사용해서 다른 타입 파라미터에 제한을 줄 수도 있다.

```kotlin
class Forest<T: Tree> {
	fun <ST: T> addTree(tree: ST) {
		//...
	}
}
```



### ✓  챕터 정리

타입 파라미터 섀도잉은 피하는게 왠만하면 좋다. 섀도잉이 되는 경우엔 코드를 반드시 주의해서 보기 바란다.

끝.

---



## 📖 제네릭 타입과 variance 한정자를 활용하라

```kotlin
class Cup<T>
```

이와 같은 제네릭 클래스가 있다고 해보자.

위 코드에서 타입 파라미터 T는 variance 한정자(out 또는 in) 가 없으므로, 기본적으로 invariant(불공변성) 이다.

invariant라는 것은 제네릭 타입으로 만들어지는 타입들이 서로 관련성이 없다는 의미이다.

예를 들어 Cup<Int> 와 Cup<Number>, Cup<Any> 와 Cup<Nothing> 은 어떠한 관련성도 갖지 않는다.

만약 어떤 관련성을 원한다면, out 또는 in이라는 variance 한정자를 붙인다.

**out은 타입 파라미터를 covariant(공변성) 로 만든다.** 이것은 A가 B의 서브 타입일 때, Cup<A>가 Cup<B>의 서브 타입이라는 의미이다.

```kotlin
class Cup<out T>
open class Dog
class Puppy: Dog()

fun main(args: Array<String>) {
	val b: Cup<Dog> = Cup<Puppy>() 	//OK
	val a: Cup<Puppy> = Cup<Dog>()	//오류
	
	val anys: Cup<Any> = Cup<Int>() 	//OK
	val nothings: Cup<Nothing> = Cup<Int>() 	//오류
}
```

**in 한정자는 반대의 의미이다. in 한정자는 타입 파라미터를 contravariant(반변성)으로 만든다.**

이는 A가 B의 서브타입일 때, Cup<A>가 Cup<B>의 슈퍼타입이라는 것을 의미한다.

```kotlin
class Cup<in T>
open class Dog
class Puppy(): Dog()

fun main(args: Array<String>) {
	val b: Cup<Dog> = Cup<Puppy>()	//오류
	val a: Cup<Puppy> = Cup<Dog>()	//OK
	
	val anys: Cup<Any> = Cup<Int>()	//오류
	val nothings: Cup<Nothing> = Cup<Int>()	//OK
}
```



### ✓  함수 타입

코틀린의 함수 타입의 **모든 파라미터 타입은 contravariant**이다. 또한 **모든 리턴 타입은 covariant**이다.

함수 타입을 사용할 때는 자동으로 variance 한정자가 사용된다.

코틀린에서 자주 사용되는 것으로는 covariant(out 한정자) 를 가진 List 가 있다.

이것은 variance 한정자가 붙지 않은 MutableList 와는 다르다.

왜 MutableList 보다 List를 더 많이 사용하는지, 그리고 어떠한 부분이 다른 것인지는 variance 한정자의 안정성의 내용을 이해하면 알 수 있다.



### ✓  variance 한정자의 안정성

**자바의 배열은 covariant**이다. 이렇게 만들어진 이유는 다양하다.

많은 출처에 따르면, 이는 **배열을 기반으로 제네릭 연산자는 정렬 함수 등을 만들기 위해서**라고 이야기한다.

그런데 자바의 배열이 covariant라는 속성을 갖기 때문에 큰 문제가 발생한다.

```java
Integer[] numbers = {1, 4, 2, 1};
Object[] objects = numbers;
objects[2] = "B";	//런타임 오류: ArrayStoreException
```

numbers를 Object[] 로 캐스팅해도 **구조 내부에서 사용되고 있는 실질적인 타입이 바뀌는 것은 아니다.**

따라서 이러한 배열에 String 타입의 값을 할당하면, 오류가 발생한다.

이것은 자바의 명백한 결함이다.

**코틀린은 이러한 결함을 해결하기 위해 Array(IntArray, CharArray 등) 를 invariant로 만들었다.**

다음 코드를 살펴보자. 파라미터 타입을 예측할 수 있다면 어떤 서브타입이라도 전달할 수 있다.

따라서 아규먼트를 전달할 때, 암묵적으로 업캐스팅할 수 있다.

```kotlin
open class Dog
class Puppy: Dog()
class Hound: Dog()

fun takeDog(dog: Dog) {}

takeDog(Dog())
takeDog(Puppy())
takeDog(Hound())
```

이는 covariant 하지 않다. covariant 타입 파라미터가 in 한정자 위치에 있다면, covariant와 업캐스팅을 연결해서, 우리가 원하는 타입을 아무거나 전달할 수 있다.

즉, value가 매우 구체적인 타입이라 안전하지 않으므로,  value를 Dog 타입으로 지정할 경우, String 타입을 넣을 수 없다.

캐스팅 후에 실질적인 객체가 그대로 유지되고, 타이핑 시스템에서만 다르게 처리되는 경우, 안전한 상황이 아니다.

이러한 상황에서 코틀린은 public in 한정자 위치에 covariant 타입 파라미터가 오는 것을 금지하여 이러한 상황을 막는다.

가시성을 priavte로 제한하면, 오류가 발생하지 않는다. 

객체 내부에서는 업캐스트 객체에 covariant를 사용할 수 없기 때문이다.



좋은 예로 T는 covariant인 **List<T>**가 있다.

지금까지 설명한 이유로 함수의 파라미터가 List<Any?>로 예측된다면, 별도의 변환 없이 모든 종류를 파라미터로 전달할 수 있다.

다만 MutableList<T>에서 T는 in 한정자 위치에서 사용되며, 안전하지 않으므로 invariant 이다.



또 다른 좋은 예로는 **Response**가 있다. variance 한정자 덕분에 이 다음 내용은 모두 참이 된다.

+ Reponse<T> 라면 T의 모든 서브타입이 허용된다.

+ Response<T1, T2> 라면 T1과 T2의 모든 서브타입이 허용된다.

+ Failure<T>라면, T의 모든 서브타입 Failure가 허용된다.

+ covariant와 Nothing 타입으로 인해서 Failure는 오류 타입을 지정하지 않아도 되고, Success는 잠재적인 값을 지정하지 않아도 된다.

  > ```kotlin
  > sealed class Response<out R, out E>
  > class Failure<out E>(val error: E): Response<Nothing, E>()
  > class Success<out R>(val value: R): Response<R, Nothing>()
  > ```



covariant와 public in 위치와 같은 문제는 contravariant 타입 파라미터와 public out 위치에서도 발생한다.

out 위치는 암묵적인 업캐스팅을 허용한다.

사실 이는 contraviant에 맞는 동작이 아니다. 이러한 상황을 막기 위해, 코틀린은 contravariant 타입 파라미터를 public out 한정자 위치에 사용하는 것을 금지한다.



### ✓  variance 한정자의 위치

variance 한정자는 크게 두 위치에 사용할 수 있다.

**첫 번째는 선언 부분이다.** 일반적으로 이 위치에 사용한다. 이 위치에서 사용하면 클래스와 인터페이스 선언에 한정자가 적용된다.

따라서 클래스와 인터페이스가 사용되는 모든 곳에 영향을 준다.

**두 번째는 클래스와 인터페이스를 활용하는 위치이다.** 이 위치에 variance 한정자를 사용하면 특정한 변수에만 variance 한정자가 적용된다.



variance 한정자를 사용하면, 위치가 제한될 수 있다. 예를 들어 MutableList<out T> 가 있다면, get으로 요소를 추출했을 때  T 타입이 나올 것이다.

하지만 set은 Nothing 타입의 아규먼트가 전달될 거라 예상되므로 사용할 수 없다.

이는 모든 타입의 서브타입을 가진 리스트(Nothing 리스트)가 존재할 가능성이 있기 때문이다.

MutableList<in T>를 사용할 경우, get과 set을 모두 사용할 수 있다.

하지만 get을 사용할 경우, 전달되는 자료형은 Any?가 된다. 이는 모든 슈퍼타입을 가진 리스트(Any 리스트)가 존재할 가능성이 있기 때문이다.



### ✓  챕터 정리

코틀린은 타입 아규먼트의 관계에 제약을 걸 수 있는 강력한 제네릭 기능을 제공한다.

이러한 기능으로 제네릭 객체를 연살할 때 굉장히 다양한 지원을 받을 수 있다.

코틀린에는 다음과 같은 타입 한정자가 있다.

+ 타입 파라미터의 기본적인 variance의 동작은 invariant이다.
+ out 한정자는 타입 파라미터를 covariant하게 만든다.
+ In 한정자는 타입 파라미터를 contravariant하게 만든다.

코틀린에서는

+ List와 Set의 타입 파라미터는 covariant이다.
+ 함수 타입의 파라미터 타입은 contravariant이다.
+ 리턴만 되는 타입에는 covariant를 사용한다.
+ 허용만 되는 타입에는 contravariant를 사용한다.

끝.

---



## 📖 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라

기업은 일반적으로 둘 이상의 플랫폼을 대상으로 하는 제품을 만들기 원하며, 요즘 대부분 기업의 제품과 서비스는 여러 플랫폼에서 돌아간다.

클라이언트와 서버를 생각해보자. 두 애플리케이션은 서로 소통하므로, 다른 플랫폼에 동일한 제품을 구현한다면, 재사용할 수 있는 부분이 더 많을 것이다.

특히 비즈니스 로직 부분들은 거의 동일하다. 따라서 소스 코드를 공유할 수 있다면, 큰 이득이 발생할 것이다.



### ✓  풀스택 개발

많은 회사가 웹 개발을 기반으로 한다. 일반적으로 웹사이트를 제품으로 사용하며, 백엔드 애플리케이션이 필요하다.

웹사이트 개발에서는 자바스크립트가 왕이다. 자바스크립트 이외의 선택지는 없을 정도로 독점적으로 사용되고 있다.

백엔드에서 가장 인기 있는 선택지는 자바이다. 두 언어는 굉장히 다르므로 일반적으로 백엔드와 웹은 분리해서 개발한다.

하지만 상황은 별할 수 있다. 코틀린은 백엔드 개발을 위한 자바의 인기 있는 대안이 되고 있다.

코틀린은 자바에서 가장 많이 활용되는 스프링 등의 다른 프레임워크들을 모두 사용할 수 있다.

최근 들어 많은 자바 백엔드 프로젝트들이 코틀린으로 이동하고 있다.

**이는 웹 백엔드, 프론트를 모두 코틀린으로 만들 수 있다는 것이다.**

이는 단순하게 만들 수 있다는 개념을 떠나서, 서로 코드를 공유할 수도 있다는 의미이다.

따라서 공통 코드, API 엔드포인트 정의, 추상화 등을 재사용할 수 있다.



### ✓  모바일 개발

이러한 기능은 모바일 세계에서 훨씬 더 유용하다. 안드로이드 전용으로만 애플리케이션을 만드는 경우는 거의 없다.

아이폰 전용으로도 만들어야 하기 때문이다.

일반적으로 애플리케이션과 iOS 애플리케이션은 거의 대부분 동일한 동작을 하고, 내부적으로 비슷한 로직을 사용하지만, 다른 언어와 도구를 사용해서 따로 개발해야 한다.

코틀린의 멀티 플랫폼 기능을 활용하면, 로직을 한 번만 구현하고, 두 플랫폼에서 이를 재사용할 수 있다.

공통 모듈을 만들고, 여기에 다양한 비즈니스 로직을 구현하면 된다.

**안드로이드의 경우, Gradle을 사용해서 동일한 방법으로 만들어지므로, 직접 사용할 수 있다. 따라서 굉장히 쉽게 공통 모듈을 활용할 수 있다.**

**iOS의 경우 LLVM을 사용하여 네이티브 코드로 컴파일할 수 있는 코틀린/네이티브를 사용하면, Objective-C 프레임워크로 변환할 수 있다.**

이렇게 변환하면 XCode 또는 AppCode에서 스위프트로 활용할 수 있다.



### ✓  라이브러리

공통 모듈을 정의할 수 있다는 것은 라이브러리에 있어서 강력한 도구이다. 

특히 플랫폼에 크게 의존하지 않는다는 점은 공통 모듈을 JVM, 자바스크립트, 네이티브 환경에서 작동하는 모든 언어에서 활용할 수 있다는 의미이다.



### ✓  함께 사용하기

+ 코틀린/JVM을 사용한 백엔드 개발 - 스프링, Ktor 등
+ 코틀린/JS를 사용한 웹사이트 개발 - 리액트 등
+ 코틀린/JVM을 사용한 안드로이드 개발 - 안드로이드 SDK 등
+ 코틀린/네이티브를 통해 Objective-C/스위프트로 iOS 프레임워크 개발
+ 코틀린/JVM을 사용한 데스크톱 개발 - TornadoFX 등
+ 코틀린/네이티브를 사용한 라즈베리파이, 리눅스, macOS 프로그램 개발



수많은 개발자가 코드를 안전하고 효율적으로 재사용할 수 있게 하는 코드 구성 방법을 계속 고안하고 있다.

지금까지 공부해본 접근 방법도 이러한 코드 구성 방법의 예시라고 할 수 있다.

공통 모듈을 사용하면 여러 플랫폼에서 코드를 재사용할 수 있다. 

따라서 이러한 접근 방법은 코드를 한 번만 작성해서 공통 논리 또는 공통 알고리즘을 재사용할 수 있게 해주는 강력한 도구라고 할 수 있다.

끝.

---

* Effective Kotlin - 마르친 모스칼라 지음
