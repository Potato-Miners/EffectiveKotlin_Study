💻 **코드 설계 - 재사용성**
=============

우리가 평소에 코드를 짜면서 보는 수많은 함수들과 라이브러리들이 과연 어떤식으로 작동하는지 궁금한적 있나?

또는 안드로이드 뷰를 만들어주는 함수들, 백엔드 개발에 사용되는 HTTP와 HTTPS 프로토콜, 로직을 짜는데 필요한 정렬 알고리즘 등 사실 내부에 구현된 자세한 내용을 몰라도 우리가 원하는 코드를 구현하는데 아무 무리가 없다.

누군가 한번 이를 만들어 놓으면 필요하거나 원할 때 언제든 사용할 수 있다.

이것이 바로 프로그래밍 언어의 핵심 특징인 **재사용성 (reusability)**이다.

재사용성은 큰 힘을 가지고 있지만, 사실 **재사용성을 고려하는 일은 생각보다 어렵고 다양한 오류를 발생시킬 수 있다.**

이번 챕터에서는 이러한 재사용성에 대해 알아볼 예정이다.

---



## 📖 knowledge를 반복하여 사용하지 말라

### "프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다."

[실용주의 프로그래머] 라는 책에서는 다음과 같은 내용을 **"Don't Repeat Yourself" (Rule's of DRY)** 라고 표현한다.

또 다른 표현으로는 **WET 안티패턴 (Write Everything Twice)**, **SSOT (Single Source of Truth)** 라고 하기도 한다.



### ✓  Knowledge

프로그래밍에서 knowledge는 넓은 의미로 **'의도적인 정보'**를 뜻한다.

알고리즘의 작동 방식, UI의 형태, 우리가 원하는 결과 등이 모두 '의도적인 정보'이며, knowledge라고 할 수 있다.

우리가 개발하는 프로그램에서 중요한 knowledge를 크게 두 가지 뽑는다면, 다음과 같다.

+ **로직 (logic)**: 프로그램이 어떤 식으로 동작하는지와 프로그램이 어떻게 보이는지
+ **공통 알고리즘 (common algorithm)**: 원하는 동작을 하기 위한 알고리즘

이 둘의 **가장 큰 차이점은 시간에 따른 변화**이다. 비즈니스 로직은 시간이 지나면서 계속해서 변하지만, 공통 알고리즘은 한 번 정의된 이후네는 크게 변하지 않는다.



### ✓  모든 것은 변화한다

프로그래밍에서 **유일하게 유지되는 것은 '변화한다는 속성**'이라는 말이 있다.

변화는 우리가 예상하지 못한 곳에서 일어난다. 특히나 UI 디자인과 기술 표준 등은 훨씬 빠르게 변화한다. 고객에 대한 이해도 매일매일 변화한다. 이처럼 우리 프로젝트의 knowledge도 계속해서 변화한다. 변화하는 몇 가지 이유를 적어보면 다음과 같다.

+ 회사가 사용자의 요구 또는 습관을 더 많이 알게 되었다.
+ 디자인 표준이 변화했다.
+ 플랫폼, 라이브러리, 도구 등이 변화해서 이에 대응해야 한다.

오늘날 대부분의 프로젝트는 몇 달마다 요구 사항과 내부적인 구조를 계속해서 변경한다. 모든 것은 변화하고, 우리는 이에 대비해야 한다.

변화할 때 가장 큰 적은 knowledge가 반복되어 있는 부분이다.

**그렇다면 프로그램 내부에서 여러 부분에 반복되어 있는 코드를 변경하려면 어떻게 해야 할까?**

가장 간단하게는 **모두 찾고 고치면 된다.** 하지만 이런 과정은 무엇보다 귀찮고 실수가 나오기 마련이다.

**knowledge의 반복은 확장성(scalable) 을 막고, 쉽게 깨지게(fragile) 만든다.**

다행히도 개발자는 knowledge의 반복을 줄일 수 있는 도구와 기능들을 활용할 수 있다.

여러 종류의 추상화를 표현할 수 있는 수많은 솔루션이 있으며, 이를 활용하면 반복을 줄일 수 있다.



### ✓  언제 코드를 반복해도 될까?

그렇다면 반대로 추출을 통해 knowledge 반복을 줄이면 안 되는 상황은 어떤 상황일까?

얼핏보면 knowledge의 반복처럼 보이지만, 실질적으로 다른 knowledge를 나타내므로 추출하면 안 되는 부분이 존재한다.

**신중하지 못한 추출은 변경을 더 어렵게 만들고, 구성을 읽을 때도 더욱 어려울 수 있다.**

코드를 추출하는 이뉴는 변경을 쉽게 만들기 위함이므로, **비즈니스 규칙이 다른 곳(source)** 에서 왔는지 확인하는 방법이 있다.

다른 곳에서 왔다면, 변경될 가능성이 높다. 잘못된 코드 추출로부터 우리를 보호할 수 있는 규칙도 있다.

바로 **단일 책임 원칙(Single Responsibility Principal, SRP)** 입니다.



### ✓  단일 책임 원칙

**단일 책임 원칙이란 '클래스를 변경하는 이유는 단 한 가지여야 한다.'** 라는 의미이다.

'두 액터가 같은 클래스를 변경하는 일은 없어햐 한다.' 이 때 액터는 변화를 만들어내는 존재를 의미한다.

액터는 서로의 업무와 분야에 대해서 잘 모르는 개발자들로 비유된다. 이러한 개발자들이 같은 코드 변경하는 것은 굉장히 위험한 일이다.

다음과 같은 **단일 책임 원칙을 사전에 방지하기 위해**서는 다음을 지켜야 한다.

+ 두 부서에서 모두 사용하는 일반적인 **public 함수로 헬퍼 함수를 만든다.** 공통 부분은 두 부서에서 모두 사용하므로, 이를 함부로 수정해서는 안되게 규약을 정한다.
+ 헬퍼 함수를 각각의 **부서 모듈에 따라 2개** 만든다.

어떤 선택지를 사용해도 헬퍼 함수를 사용하기에 안전하다.

또한 단일 책임 원칙은 우리에게 두 가지의 사실을 알려준다.

+ 서로 다른 곳에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많다. 따라서 **비슷한 처리를 하더라도 다른 knowledge로 취급하는 것**이 좋다.
+ **다른 knowledge는 분리해 두는 것이 좋다.** 그렇지 않으면, 재사용해서는 안 되는 부분을 재사용하려는 유혹이 발생할 수 있다.



### ✓  챕터 정리

여러 요소에 비슷한 부분이 있는 경우, 변경이 필요할 때 실수가 발생할 수 있다. 이런 부분은 추출하는 것이 좋다.

의도하지 않은 수정을 피하려면 또는 다른 곳에서 조작하는 부분이 있다면, 분리해서 사용하는 것이 좋다.

그렇다고해서 극단적인 것이 항상 좋은 것은 아니다. 균형이 중요하다.

끝.

---



## 📖 일반적인 알고리즘을 반복해서 구현하지 말라

많은 개발자들은 같은 알고리즘을 여러 번 반복해서 구현한다.

하지만 stdlib 같이 이미 존재하는 알고리즘 등을 활용하면, 단순하게 코드가 짧아진다는 것 이외에도 다양한 장점이 있다.

+ 코드 작성 속도가 빨라진다.
+ 구현을 따로 읽지 않아도, 함수의 이름 등만 보고 무엇을 하는지 확실하게 알 수 있다.
+ 직접 구현할 때 발생할 수 있는 실수를 줄일 수 있다.
+ 제작자들이 한 번만 최적화하면, 이러한 함수를 활용하는 모든 곳이 최적화의 혜택을 받을 수 있다.



### ✓  표준 라이브러리 살펴보기

일반적인 알고리즘은 대부분 이미 다른 사람들이 정의해 놓았다. 그중에서 가장 대표적인 라이브러리는 바로 표준 라이브러리인 stdlib이다.

stdlib의 함수들을 하나하나 살펴보는 것은 굉장히 어려울 수 있지만, 그럴만한 가치가 있는 일이다.

만약 이를 자세히 살펴보지 않으면, 계속해서 같은 함수를 여러 번 만들게 될 것이다.

**따라서 라이브러리를 사용할 때는 사용하려는 함수에 대해 명확하게 알고 최적의 함수를 찾아 사용하는 것이 중요하다.**



### ✓  나만의 유틸리티 구현하기

상황에 따라서 표준 라이브러리에 없는 알고리즘이 필요할 수도 있다. 

예를 들어 컬렉션에 있는 모든 숫자의 곱을 계산하는 라이브러리가 필요하다면 어떻게 해야할까?

이는 널리 알려 추상화이므로 **범용 유틸리티 함수(univeral utility function) 으로 정의**하는 것이 좋다.

```kotlin
fun Iterable<Int>.product() =
	fold(1) { acc, i -> acc * i }
```

여러번 사용되지 않는다고 해도 이처럼 만드는 것이 좋다.

이는 잘 알려진 수학적 개념이고, product라는 이름이 숫자를 곱할 거라는 것은 대부분의 개발자들이 예측할 수 있기 때문이다.

하지만 동일한 결과를 얻는 함수를 여러 번 만드는 것은 잘못된 일이다. 

**모든 함수는 테스트되어야 하고, 기억되어야 하며, 유지보수되어야 한다.**

따라서 함수를 만들 때는 이러한 비용이 들어갈 수 있다는 것을 전제해야 한다.

**필요없는 함수를 중복해서 만들지 않게, 기존에 관련된 함수가 있는지 탐색하는 과정이 필요하다.**

사실 위의 product 함수도 kotlin의 stdlib 라이브러리 안에서 확장 함수로 구현이 되어 있다.

많이 사용되는 알고리즘을 추출하는 방법으로는 톱레벨 함수, 프로퍼티 위임, 클래스 등이 있다.

확장 함수는 이러한 방법들과 비교해서, 다음과 같은 장점을 갖는다.

+ **함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋다.** 특히 부가 작용(side-effect) 이 없는 경우에는 더 좋다.
+ 톱레벨 함수와 비교해서, **확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한**할 수 있으므로 좋다.
+ 수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 **확장 리시버로 사용하는 것**이 가독성 측면에서 좋다.
+ 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능 등으로 제안이 이루어지므로 **쉽게 찾을 수 있다.**



### ✓  챕터 정리

일반적인 알고리즘을 반복해서 만들지 말자. 대부분은 이미 stdlib에 이미 정의되어 있을 가능성이 높다. 따라서 stdlib를 더 공부해 두자.

특정 알고리즘을 반복해서 사용해야 하는 경우에는 **프로젝트 내부에 직접 정의**하자. 일반적으로 이런 알고리즘은 **확장 함수를 사용**해서 정의하자.

끝.

---



## 📖 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라

코틀린은 코드 재사용과 관련해서 **프로퍼티 위임**이라는 새로운 기능을 제공한다.

프로퍼티 위임을 사용하면 일반적인 프로퍼티의 행위를 추출해서 재사용할 수 있다.

대표적인 예로 **지연 프로퍼티**가 있다. **처음 사용하는 요청이 들어올 때 초기화되는 프로퍼티를 의미한다.**

자바의 경우에는 이를 구현하려면 굉장히 복잡한 구현이 필요하지만, 코틀린에서는 프로퍼티 위임을 활용해 간단하게 구현할 수 있다.

```kotlin
val value by laze { createValue() }
```

지연 프로퍼티 이외에도 변화가 있을 때 감지하는 observable 패턴을 쉽게 만들 수 있다.

```kotlin
var items: List<Item> by
	Delegates.observable(listOf()) { _, _, _ ->
		notifyDataSetChanged()	
}

var key: String? by
	Delegates.observable(null) { _, old, new ->
 		Log.e("key changed from $old to $new")                            
}
```

lazy와 observable 델리게이터는 사실 언어적인 관점으로 보았을 때, 그렇게 특별한 것은 아니다.

일반적으로 프로퍼티 위임 메커니즘을 활용하면, 다양한 패턴들을 만들 수 있다. 좋은 예로 **뷰, 리소스 바인딩, 의존성 주입, 데이터 바인딩** 등이 있다.

이와 같은 패턴들을 자바에서 사용하려면 다양한 어노테이션을 많이 활용해야 한다.

하지만 코틀린은 프로퍼티 위임을 사용해서 간단하고 type-safe하게 구현할 수 있다.

```kotlin
var token: String? by LoggingProperty(null)
var attempts: Int by LoggingProperty(0)

private class LoggingProperty<T>(var value: T) {
	operator fun getValue(
		thisRef: Any?,
		prop: KProperty<*>
	): T {
		print("${prop.name} returned value $value")
		return value
	}
	
	operator fun setValue(
		thisRef: Any?,
		prop: KProperty<*>,
		newValue: T
	) {
		val name = prop.name
		print("$name changed from $value to $newValue")
		value = newValue
	}
}
```

**프로퍼티 위임은 다른 객체의 메서드를 활용해서 프로퍼티의 접근자(게터와 세터) 를 만드는 방식**이다.

이때 **게터는 getValue, 세터는 setValue 함수를 사용**해서 만들어야 한다. 

객체를 만든 뒤에는 **by 키워드를 사용**해서, getValue와 setValue를 정의한 클래스와 연결해 주면 된다.

프로퍼티 위임이 어떻게 동작하는지 이해하려면, by가 어떻게 컴파일되는지 보는 것이 좋다.

**getValue와 setValue는 단순하게 값만 처리하게 바뀌는 것이 아니라, 컨텍스트(this) 와 프로퍼티 레퍼런스의 경계도 함께 사용하는 형태로 바뀐다.**

또한 컨텍스트는 함수가 **어떤 위치에서 사용되는지와 관련된 정보를 제공**해 준다.

이는 **getValue와 setValue 메서드가 여러 개 있어도 문제 없다**는 뜻이다. (컨텍스트를 활용하므로 상황에 따라 적절한 메서드가 선택된다.)

코틀린 stdlib에서 굉장히 범용적으로 사용되는 패턴들에 대한 프로퍼티 델리게이터들을 알아 두면 좋다.

+ lazy
+ Delegates.observable
+ Delegates.vetoable
+ Delegates.notNull



### ✓  챕터 정리

**프로퍼티 델리게이트는 프로퍼티와 관련된 다양한 조작을 할 수 있으며, 컨텍스트와 관련된 대부분의 정보를 갖는다.**

이러한 특징으로 인해 다양한 **프로퍼티의 동작을 추출해 재사용**할 수 있다.

끝.

---



## 📖 일반적인 알고리즘을 구현할 때 제네릭을 사용하라

아규먼트로 함수에 값을 전달할 수 있는 것처럼, 타입 아규먼트를 사용하면 함수에 타입을 전달할 수 있다.

이를 **제네릭 함수(generic function)** 이라고 부른다.

대표적인 예로는 stdlib의 filter 함수가 있다.

타입 파라미터는 타입에 대한 정보를 제공하여 **컴파일러가 타입을 조금이라도 더 정확하게 추측할 수 있게 해준다.** 

따라서 프로그램이 조금 더 안전해지고, 개발자는 프로그래밍이 편해진다.

제네릭은 기본적으로 List<String> 또는 Set<User> 처럼 구체적인 타입으로 컬렉션을 만들 수 있게 클래스와 인터페이스에 도입된 기능이다.

이와 같은 기능은 정적 타입 프로그래밍 언어에서는 굉장히 유용하게 활용된다.

코틀린은 강력한 제네릭 기능을 갖고 있지만, 조금 복잡해서 이해하기 어렵다.



### ✓  제네릭 제한

타입 파리미터의 중요한 기능 중 하나는 **구체적인 타입의 서브타입만 사용하게 타입을 제한**하는 것이다. 

예를 들어 T를 Iterable<Int> 의 서브타입으로 제한하면, T 타입을 기반으로 반복 처리가 가능하고, 반복 처리 때 사용되는 객체가 Int라는 것을 알 수 있다.

또한 Comparable<T> 로 제한하면, 해당 타입을 비교할 수 있다는 것을 알 수 있다.



### ✓  챕터 정리

코틀린 자료형 시스템에서 타입 파라미터는 굉장히 중요한 부분이다. 일반적으로 이를 사용해서 **type-safe 제네릭 알고리즘과 제네릭 객체를 구현**한다.

타입 파라미터는 **구체 자료형(concrete type)** 의 서브타입을 제한할 수 있다. 이렇게 하면 특정 자료형이 제공하는 메서드를 안전하게 사용할 수 있다.

---

* Effective Kotlin - 마르친 모스칼라 지음
