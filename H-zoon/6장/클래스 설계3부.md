### **1. 아이템 42: compareTo의 규약을 지켜라**

- **`compareTo()`**는 **`Any`** 클래스의 메서드가 아니며, 수학적인 부등식으로 변환될 수 있는 연산자다.
- **`compareTo()`**는 **`Comparable<T>`** 인터페이스에도 있음. 이는 해당 객체가 비교 가능하다는 의미다.
- **`compareTo`**의 규약:
    1. **비대칭적 동작** : a와 b가 동등하다면 a와 b의 비교 결과는 같아야 한다.
    2. **연속적 동작** : a >= b, b >= c면 a >= c여야 한다.
    3. **코넥스적 동작** : 두 요소 간에 확실한 관계가 있어야 한다.
- 코틀린에서는 일반적으로 **`compareTo`**를 따로 정의할 필요가 거의 없다. 대신, **`sortedBy`**나 **`sortedWith`** 함수를 사용하여 원하는 기준에 따라 정렬할 수 있다.

---

### **2. 아이템 43: API의 필수적이지 않은 부분을 확장 함수로 추출하라**

- 확장 함수는 기본적으로 클래스가 아니라 타입에 정의한다. 따라서 nullable이나 구체적인 제네릭 타입에 확장 함수를 정의할 수 있다.
- 확장 함수와 멤버 함수의 차이점:
    1. 확장 함수는 별도로 가져와 사용해야 한다.
    2. 확장 함수는 정적으로 선택되므로 오버라이드할 수 없다.
    3. 확장 함수는 클래스 레퍼런스에서 멤버로 표시되지 않는다.
- 확장 함수는 클래스의 public API만 사용하면 위치에 상관없이 사용할 수 있다.

---

### **3. 아이템 44: 멤버 확장 함수의 사용을 피하라**

- 클래스에 대한 확장 함수를 멤버로 추가하는 것은 바람직하지 않다.
- 확장 함수는 첫 번째 아규먼트로 리시버를 받는 일반 함수로 컴파일된다.
- 확장 함수를 멤버로 정의하는 것은 특히 가시성 제한을 위한 경우에는 좋지 않다.
- 멤버 확장 함수를 피해야 하는 주된 이유:
    1. 레퍼런스 지원이 없다.
    2. 암묵적 접근 시 혼동이 생길 수 있다.
    3. 확장 함수의 동작이 명확하지 않을 수 있다.
    4. 초보 개발자에게는 확장 함수가 직관적이지 않을 수 있다.
