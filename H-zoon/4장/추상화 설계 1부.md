# 4장

# 아이템26 - 함수 내부의 추상화 레벨을 통일해라

계층이 잘 분리되면 무엇이 좋은가? 어떤 계층에서 작업할 때 그 아래의 계층은 이미 완성돼 있으므로 해당 계층만 생각하면 된다는 것이다. 즉 전체를 이해할 필요가 없어진다. 예를 들어 어셈블리어, JVM 바이트코드가 뭔지 몰라도 프로그래밍할 수 있다. 개발자는 일반적으로 특정 계층에서 작업하며 가끔 그 위에 추가로 계층을 올려 사용한다.

## 추상화 레벨

일반적으로 컴퓨터 과학자들은 어떤 계층이 높은 레벨인지 낮은 레벨인지를 구분한다. 높은 레벨로 갈수록 물리 장치로부터 점점 멀어진다. 프로그래밍에선 일반적으로 높은 레벨일수록 프로세서로부터 멀어진다고 표현한다. 높은 레벨일수록 걱정해야 하는 세부적인 내용들이 적다. 하지만 무엇이든 좋을 수는 없다. 높은 레벨일수록 단순함을 얻지만 제어력을 잃는다. C언어는 메모리 관리를 직접할 수 있다. 반면 자바는 가비지 컬렉터가 자동으로 메모리를 관리해주기 때문에 메모리 사용을 최적화하는 것이 굉장히 힘들다.

## 추상화 레벨 통일

코드도 추상화를 계층처럼 만들어 사용할 수 있다. 이를 위한 기본 도구가 함수다. 컴퓨터 과학이 높은 레벨, 낮은 레벨을 확실하게 구분하고 있는 것처럼 함수도 높은 레벨, 낮은 레벨을 구분해서 써야 한다는 원칙이 있다. 이를 **추상화 레벨 통일(Single Level of Abstraction, SLA) 원칙**이라 부른다.

버튼 하나만 누르면 커피를 만들 수 있는 커피 머신을 나타내는 클래스를 만든다고 가정한다. 커피를 만드는 것은 커피 머신의 여러 부분들이 필요한 복잡한 작업이다. 아래처럼 makeCoffee라는 함수 하나를 갖는 CoffeeMachine 클래스를 만든다. 이 함수 내부에는 여러 로직들을 구현할 수 있을 것이다.

```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        // 여러 변수 선언
        // 복잡한 로직 처리
        // 낮은 수준의 최적화
    }
}
```

하지만 이렇게 작성하면 makeCoffee()가 수백 줄이 될 수도 있다. 오래된 프로그램들은 이런 식으로 한 함수에 수많은 로직을 때려 넣어서 개발된 경우가 많다. 이런 함수는 함수를 읽으면서 세부적인 내용을 하나하나 신경써야 하므로 읽고 이해하는 게 거의 불가능에 가깝다. 만약 이런 코드에서 물의 온도를 수정해 달라는 요청을 받았다고 가정한다. 어딜 어떻게 수정해야 할지 감도 안 올 것이다. 그래서 최근에는 아래처럼 함수를 계층처럼 나눠서 쓰는 것이다.

```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        boilWater()
        brewCoffee()
        pourCoffee()
        pourMilk()
    }

    private fun boilWater() {}
    private fun brewCoffee() {}
    private fun pourCoffee() {}
    private fun pourMilk() {}
}
```

이제 이 함수가 어떻게 동작하는지 확실하게 확인할 수 있다. makeCoffee()는 누군가가 낮은 레벨(boilWater(), brewCoffee() 등)을 이해해야 한다면 해당 부분의 코드만 보면 된다. 매우 간단한 추상화를 추출해서 가독성을 향상시킨 것이다.

이처럼 함수는 간단해야 한다. 이는 '함수는 작아야 하며 최소한의 책임만 가져야 한다'는 일반적인 규칙이다. 또한 어떤 함수가 다른 함수보다 좀 복잡하다면 일부분을 추출해서 추상화하는 게 좋다. 모든 추상화 레벨에서 추상 요소(메서드 또는 클래스)를 조작한다. 각각의 추상 요소가 어떤 내용을 담고 있는지 확인하고 싶다면 정의로 이동해서 확인하면 된다.

추가로 이런 형태로 함수를 추출하면 재사용과 테스트가 쉬워진다. makeCoffee()는 물 끓이고 커피 내리고, 커피를 붓고, 우유를 넣어서 라떼를 만드는 과정이다. 만약 에스프레소 커피를 만드는 기능을 추가한다면 우유만 안 넣으면 된다. 또한 boilWater(), brewWater() 같은 작은 함수도 테스트할 수 있기 때문이다.

## 프로그램 아키텍처의 추상 레벨

추상화 계층이라는 개념은 함수보다 높은 레벨에서도 적용할 수 있다. 추상화를 구분하는 이유는 서브시스템의 세부사항을 숨김으로써 상호 운영성과 플랫폼 독립성을 얻기 위함이다. 이는 문제 중심으로 프로그래밍한다는 의미다.

이런 개념은 모듈 시스템을 설계할 때도 중요하다. 모듈을 분리하면 계층 고유의 요소를 숨길 수 있다. 앱을 만들 때는 입출력을 나타내는 모듈(프론트엔드의 뷰, 백엔드의 HTTP 요청 처리 등)은 낮은 레벨의 모듈이다. 그리고 비즈니스 로직을 나타내는 부분이 높은 레벨의 모듈이다.

계층이 잘 분리된 프로젝트를 계층화가 잘 됐다고 부른다. 계층화가 잘 된 프로젝트를 좋은 프로젝트라고 부른다. 계층화가 잘 된 프로젝트는 어떤 계층 위치에서 코드를 봐도 일반적인 관점을 얻을 수 있다.

# 아이템 27 - 변화로부터 코드를 보호하려면 추상화를 사용하라

함수, 클래스 등의 추상화로 실질적인 코드를 숨기면 사용자가 세부사항을 알지 못해도 괜찮다는 장점이 있다. 그리고 이후에 실질적인 코드를 원하는 대로 수정할 수도 있다. 예를 들어 정렬 알고리즘을 함수로 추출하면 이를 쓰는 코드에 어떤 영향도 주지 않고 함수 성능을 최적화할 수 있다.

자동차 제조업체와 엔지니어는 자동차 내부의 원하는 걸 마음대로 바꿀 수 있다. 작동만 제대로 된다면 사용자는 뭐가 바뀐지 전혀 모를 것이다. 여기선 추상화를 통해 변화로부터 코드를 보호하는 행위가 어떤 자유를 가져오는지 확인한다. 가장 간단한 추상화인 상수부터 알아본다.

## 상수

리터럴은 아무것도 설명하지 않는다. 따라서 코드에서 반복 등장할 때 문제가 된다. 이런 리터럴을 상수 프로퍼티로 변경하면 해당 값에 의미있는 이름을 붙일 수 있으며 상수값을 바꿔야 할 때 쉽게 바꿀 수 있다. 비밀번호 유효성을 검사하는 간단한 예를 확인한다.

```kotlin
fun isPasswordValid(text: String): Boolean {
    if (text.length < 7) return false
    // ...
}
```

여기서 숫자 7은 아마 비밀번호의 최소 길이를 나타내겠지만 이해하는 데 시간이 걸린다. 상수로 빼면 훨씬 쉽게 이해할 수 있을 것이다.

```kotlin
const val MIN_PASSWORD_LENGTH = 7

fun isPasswordValid(text: String): Boolean {
    if (text.length < MIN_PASSWORD_LENGTH) return false
    // ...
}
```

이렇게 하면 비밀번호의 최소 길이를 바꾸기도 쉽다. 함수 내부 로직을 전혀 이해하지 못해도 상수값만 바꾸면 된다. 그래서 2번 이상 쓰이는 값은 이렇게 상수로 추출하는 게 좋다. 예를 들어 DB에 동시 연결할 수 있는 최대 쓰레드 수를 아래처럼 정의했다고 가정한다.

```kotlin
val MAX_THREADS = 10
```

일단 이렇게 추출하면 변경이 필요할 때 쉽게 바꿀 수 있다. 이런 숫자가 프로젝트 전체에 퍼져 있다면 변경하기 힘들 것이다. 상수로 추출하면

- 이름을 붙일 수 있고
- 나중에 해당 값을 쉽게 바꿀 수 있다

이는 다른 추상화 방법에서도 적용되는 얘기다.

## 함수

앱을 개발하고 있는데 사용자에게 토스트 메시지를 자주 출력해야 하는 상황이 발생했다고 가정한다. 기본적으로 아래와 같은 코드로 토스트 메시지를 출력한다.

```kotlin
Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
```

이렇게 많이 쓰이는 알고리즘은 아래처럼 간단한 확장 함수로 만들어서 사용할 수 있다.

```kotlin
fun Context.toast(
    message: String,
    duration: Int = Toast.LENGTH_SHORT
) {
    Toast.makeText(this, message, duration).show()
}
```

이렇게 일반적인 알고리즘을 추출하면 토스트 출력 코드를 기억하지 않아도 괜찮다. 또한 거의 일어나지 않겠지만 이후에 토스트를 출력하는 방법이 변경돼도 확장 함수 부분만 수정하면 되므로 유지보수성이 향상된다. 스낵바로 출력해야 한다면 스낵바를 출력하는 확장 함수를 만들고 기존의 Context.toast()를 Context.snackbar()로 한꺼번에 바꾸면 된다.

하지만 이런 해결법은 좋지 않다. 내부적으로만 사용하더라도 함수명을 직접 바꾸는 것은 위험할 수 있다. 다른 모듈이 이 함수에 의존하고 있다면 다른 모듈에 큰 문제가 발생할 것이다. 또한 함수명은 한꺼번에 바꾸기 쉽지만 파라미터는 한꺼번에 바꾸기 쉽지 않으므로 메시지 지속시간을 나타내기 위한 Toast.LENGTH_SHORT가 계속 쓰이고 있다는 문제도 있다.

메시지 출력 방법이 바뀔 수 있다는 걸 알고 있다면 중요한 것은 메시지 출력 방법이 아니라 사용자에게 메시지를 출력하고 싶다는 의도 자체다. 따라서 메시지를 출력하는 더 추상적인 방법이 필요하다. 토스트 출력을 토스트란 개념과 무관한 showMessage()라는 높은 레벨의 함수로 옮긴다.

```kotlin
fun Context.showMessage(
    message: String,
    duration: MessageLength = MessageLength.LONG
) {
    val toastDuration = when (duration) {
        MessageLength.SHORT -> Toast.LENGTH_SHORT
        MessageLength.LONG -> Toast.LENGTH_LONG
    }
    Toast.makeText(this, message, toastDuration).show()
}

enum class MessageLength { SHORT, LONG }
```

가장 큰 변화는 이름이다. 일부 개발자는 이름 변경은 그냥 레이블을 붙이는 방식의 변화이므로 큰 차이가 없다고 생각하기도 한다. 하지만 이런 관점은 컴파일러 관점에서만 유효하다. 사람 관점에선 이름이 바뀌면 큰 변화가 일어난 것이다. 함수는 추상화를 표현하는 수단이며 함수 시그니처는 이 함수가 어떤 추상화를 표현하고 있는지 알려준다. 따라서 의미있는 이름은 굉장히 중요하다.

함수는 매우 단순한 추상화지만 제한이 많다. 함수는 상태를 유지하지 않는다. 또한 함수 시그니처를 바꾸면 프로그램 전체에 큰 영향을 줄 수 있다. 구현을 추상화할 수 있는 더 강한 방법은 클래스가 있다.

## 클래스

이전의 메시지 출력을 클래스로 추상화한다.

```kotlin
enum class MessageLength { SHORT, LONG }

class MessageDisplay(val context: Context) {
    fun show(
        message: String,
        duration: MessageLength = MessageLength.SHORT
    ) {
        val toastDuration = when (duration) {
            MessageLength.SHORT -> Toast.LENGTH_SHORT
            MessageLength.LONG -> Toast.LENGTH_LONG
        }
        Toast.makeText(context, message, toastDuration).show()
    }
}
```

클래스가 함수보다 더 강력한 이유는 상태를 가질 수 있으며 많은 함수를 가질 수 있다는 점 때문이다. 클래스 멤버 함수를 메서드라 부른다. 현재 위의 코드에서 클래스 상태인 context는 기본 생성자로 주입된다. 의존성 주입 프레임워크를 쓰면 클래스 생성을 위임할 수도 있다.

```kotlin
@Inject lateinit var messageDisplay: MessageDisplay
```

그리고 메시지를 출력하는 더 다양한 종류의 메서드를 만들 수도 있다.

```kotlin
messageDisplay.setChristmasMode(true)
```

이처럼 클래스는 훨씬 더 많은 자유를 보장해준다. 하지만 여전히 한계가 있다. 클래스가 final이라면 해당 클래스 타입 아래에 어떤 구현이 있는지 알 수 있다. open 클래스를 쓰면 조금은 더 자유를 얻을 수 있다. open 클래스는 서브클래스를 대신 제공할 수 있기 때문이다. 더 많은 자유를 얻으려면 더 추상적으로 만들면 된다. 인터페이스 뒤에 클래스를 숨기는 방법이다.

## 인터페이스

코틀린 표준 라이브러리를 읽어보면 거의 모든 것이 인터페이스로 표현된다는 걸 확인할 수 있다. 예를 들어

- listOf()는 List를 리턴한다. 여기서 List는 인터페이스다. listOf()는 팩토리 메서드라고 할 수 있다
- 컬렉션 처리 함수는 Iterable 또는 Collection의 확장 함수로서 List, Map 등을 리턴한다. 이것들은 모두 인터페이스다
- 프로퍼티 위임은 ReadOnlyProperty 또는 ReadWriteProperty 뒤에 숨겨진다. 이것들도 모두 인터페이스다. 실질적인 클래스는 일반적으로 private다. 함수 lazy는 Lazy 인터페이스를 사용한다

지금까지 봤던 메시지 표시 예제에 인터페이스를 도입한다. 클래스를 인터페이스 뒤에 숨긴다는 건 아래처럼 한다는 의미다.

```kotlin
enum class MessageLength { SHORT, LONG }

class ToastDisplay(val context: Context): MessageDisplay {
    override fun show(message: String, duration: MessageLength) {
        val toastDuration = when (duration) {
            MessageLength.SHORT -> Toast.LENGTH_SHORT
            MessageLength.LONG -> Toast.LENGTH_LONG
        }
        Toast.makeText(context, message, toastDuration).show()
    }
}

interface MessageDisplay {
    fun show(message: String, duration: MessageLength = MessageLength.SHORT)
}
```

이렇게 구성하면 더 많은 자유를 얻을 수 있다. 이런 클래스는 태블릿에서 토스트를 출력하게 만들 수도 있고 스낵바를 출력하게 할 수도 있다. 또한 안드로이드, iOS, 웹에서 공유해 사용하는 공통 모듈에서도 사용할 수 있다. 각 플랫폼에서 구현만 조금 다르게 하면 된다. 또 다른 장점은 테스트 시 인터페이스 페이킹이 클래스 모킹보다 간단하므로 별도의 모킹 라이브러리를 안 써도 된다는 것이다.

## ID 만들기(nextId)

프로젝트에서 고유 ID를 써야 하는 상황을 가정한다. 가장 간단한 방법은 어떤 정수값을 계속 증가시키면서 이를 ID로 활용하는 것이다.

```kotlin
var nextId: Int = 0

// 사용
val newId = nextId++
```

그런데 이런 코드가 많이 쓰이면 약간 위험하다. ID가 생성되는 방식을 변경할 때 문제가 발생한다. 이 방법은 아래의 문제들이 있다.

- 이 코드의 ID는 무조건 0부터 시작한다
- 이 코드는 쓰레드 세이프하지 않다

그래도 이 방법을 써야 한다면 이후에 발생할 수 있는 변경으로부터 코드를 보호할 수 있게 함수를 쓰는 게 좋다.

```kotlin
private var nextId: Int = 0
fun getNextId(): Int = nextId++

// 사용
val newId = getNextId()
```

이제 ID 생성 방식의 변경으로부터는 보호되지만 ID 타입 변경 등은 대응하지 못한다. 미래의 어느 시점에 ID를 문자열로 바꿔야 한다면 어떤가? 그 시점 이전에 ID가 계속 Int로 유지될 거라 생각해서 여러 연산들이 타입에 종속적이게 작성됐다면? 이를 최대한 방지하려면 이후에 ID 타입을 쉽게 변경할 수 있게 클래스를 쓰는 게 좋다. 더 많은 추상화는 더 많은 자유를 주지만 이를 정의, 사용, 이해하는 게 조금 어려워졌다.

## 추상화가 주는 이점

지금까지 본 추상화 방법들을 구현할 때 여러 도구를 활용할 수 있다.

- 제네릭 타입 파라미터를 사용한다
- 내부 클래스를 추출한다
- 생성을 제한한다(팩토리 함수로만 객체를 만들 수 있게 만드는 등)

하지만 추상화에는 단점도 있다.

## 추상화의 문제

어떤 방식으로 추상화하려면 코드를 읽는 사람이 해당 개념을 배우고 잘 이해해야 한다. 또 다른 방식으로 추상화하려면 또 해당 개념을 배우고 잘 이해해야 한다. 물론 추상화 가시성을 제한하거나 구체적인 작업에서만 추상화를 도입하는 것은 큰 문제가 없다. 그래서 큰 프로젝트에선 잘 모듈화해야 한다. 어쨌거나 추상화도 비용이 발생한다. 따라서 극단적으로 모든 걸 추상화해선 안 된다.

추상화는 많은 걸 숨길 수 있는 테크닉이다. 너무 많은 것을 숨기면 결과 이해 자체가 어려워진다. 추상화가 너무 많으면 코드를 이해하기 어렵다.

## 어떻게 균형을 맞출까

모든 추상화는 자유를 주지만 코드가 어떻게 돌아가는지 이해하기 어렵게 만든다. 극단적인 것은 언제나 좋지 않다. 최상의 답은 언제나 그 사이 어딘가에 있다. 적절한 균형을 찾는 건 거의 감각에 의존해야 하는 예술에 가깝다. 수천 시간까진 아니더라도 수백 시간의 경험이 있어야 할 수 있는 일이다.

항상 뭔가 변화할 수 있다고 생각하는 것이 좋다. 이후에 더 일반적인 매커니즘이 필요할 가능성이 있는지, 플랫폼 독립적인 매커니즘이 필요할 수 있는지 등은 여러 경험을 해보면 어느 정도 알 수 있게 된다.

# 아이템 28 - API 안정성을 확보하라

프로그래밍에서도 안정적이고 최대한 표준적인 API를 선호한다. 주요 이유는 아래와 같다.

**API가 바뀌고 개발자가 이를 업데이트했다면 여러 코드를 수동으로 업데이트해야 한다**. 

많은 요소가 이 API에 의존하고 있다면 큰 문제가 된다. 변경에 대응하거나 다른 대안을 찾는 건 어렵다. 특히 다른 개발자가 API를 사용한 경우에는 익숙하지도 않아 더 어려울 것이다. 라이브러리의 작은 변경은 이를 활용하는 다른 코드들의 많은 부분을 변경하게 만들 수 있다. 그래서 라이브러리가 바뀌어도 이전 라이브러리를 유지하는 경우가 많다. 하지만 그럴수록 점점 업데이트가 어려워지고 버그, 취약성 등이 발생할 수 있다. 오래된 라이브러리는 더 이상 지원되지 않을 수도 있다. 따라서 개발자가 안정적인 라이브러리로 업데이트하는 걸 두려워한다는 건 매우 안 좋은 상황이다

**사용자가 새 API를 배워야 한다.** 

새로 배운다는 것은 힘들고 고통스러운 일이므로 많은 사람이 이를 피한다. 하지만 새로 배우지 않으면 오래된 지식 때문에 보안 문제가 발생할 수 있다. 따라서 처음부터 안정적이지 않은 모듈을 많이 공부하는 것보다는 안정적인 모듈부터 공부해두는 게 좋다.

좋은 API를 한 번에 설계할 수는 없다. API 제작자는 이를 계속 개선하기 위해 변경을 원한다. 따라서 프로그래밍 커뮤니티는 계속 API를 안정적으로 유지하기 위한 의견을 제시해 균형을 맞춰야 한다.

간단한 방법은 작성자가 API 또는 API 일부가 불안정하다면 이를 명확하게 알려 줘야 한다. 많은 버저닝 시스템이 있지만 일반적으로 시멘틱 버저닝을 사용한다. 이 시스템은 버전 번호를 3개 번호, 즉 MAJOR, MINOR, PATCH로 나눠 구성한다. 각 부분은 0 이상의 정수로 구성되며 0부터 시작해서 API에 아래와 같은 변경사항이 있을 때 1씩 증가시킨다

- MAJOR 버전 : 호환되지 않는 수준의 API 변경
- MINOR 버전 : 이전 변경과 호환되는 기능 추가
- PATCH 버전 : 간단한 버그 수정

버전은 MAJOR.MINOR.PATCH 형태로 붙인다. MAJOR를 증가시킬 때는 MINOR, PATCH를 0으로 돌려 둔다. 사전 배포와 빌드 메타데이터 등은 추가적인 레이블을 활용한다. 메이저 버전이 0인 경우(0.y.z)는 초기 개발 전용 버전을 의미한다. 따라서 언제든 바뀔 수 있고 안정적이지 않다는 의미다. 따라서 라이브러리, 모듈이 시멘틱 버저닝에 따라 버전이 붙는다면 MAJOR 버전이 0일 때는 안정적인 거라고 생각하면 안 된다.

안정적인 API에 새 요소를 추가할 때 아직 해당 요소가 안정적이지 않다면 먼저 다른 브랜치에 해당 요소를 두는 게 좋다. 일부 사용자가 이를 사용하도록 허용하려면 일단 Experimental 메타 어노테이션을 써서 사용자들에게 아직 해당 요소가 안정적이지 않다는 것을 알려주는 게 좋다.

# 아이템 29 - 외부 API 를 wrap해서 사용하라

API 설계자가 안전하지 않다고 하거나 API 설계자가 안전하다고 해도 우리가 그걸 신뢰할 수 없다면 그 API는 불안정한 것이다. 이런 불안정한 API를 과도하게 사용하는 것은 굉장히 위험하다. 어쩔 수 없이 이런 API를 써야 한다면 최대한 로직과 직접 결합시키지 않는 게 좋다. 그래서 많은 프로젝트가 잠재적으로 불안정하다고 판단되는 외부 라이브러리 API를 랩해서 사용한다. 랩해서 사용하면 아래와 같은 자유, 안정성을 얻을 수 있다.

- 문제가 있다면 wrapper만 바꾸면 되므로 API 변경에 쉽게 대응 가능하다
- 프로젝트 스타일에 맞춰서 API 형태를 조정할 수 있다
- 특정 라이브러리에서 문제가 발생하면 wrapper를 수정해서 다른 라이브러리를 쓰도록 코드를 쉽게 바꿀 수 있다
- 필요한 경우 쉽게 동작을 추가하거나 수정할 수 있다

단점은 아래와 같다

- wrapper를 따로 정의해야 한다
- 다른 개발자가 프로젝트를 다룰 때 어떤 래퍼들이 있는지 따로 확인해야 한다
- wrapper들은 프로젝트 내부에서만 유효하므로 문제가 생겨도 질문할 수 없다. 스택오버플로우에 질문해도 아무도 답해주지 못할 것이다

장단점을 모두 이해하고 랩할 API를 이해해야 한다. 라이브러리가 얼마나 안정적인지 확인할 수 있는 가장 기본적인 휴리스틱은 버전 번호와 사용자 수다. 일반적으로 라이브러리 사용자가 많을수록 안정적이다.
