# 아이템1: 가변성을 제한하라

## 코틀린에서 가변성을 유의해서 사용해야 하는 이유

1. 코드의 이해도가 떨어지고 디버깅 난이도가 올라간다. )→ 상태를 이해하고 상태변경을 추적해야 하기 때문에
2. 실행 추론이 어려워진다. )→ 시점에 따라 값이 변화하기 때문에.
3. 멀티쓰레드 환경에서는 적절한 동기화가 필요하다.)→ 변경이 발생하는 부분에서 충돌이 발생할 수 있기 때문.
4. 상태변경이 발생했을 때. 적절히 전파해야한다.)→ ex: 리스트 상태변경이 발생한 경우 리스트 전체를 정렬해야 함.

```kotlin
var num = 0
    for (i in 1..100){
        thread {
            Thread.sleep(10)
            num =+ 1
        }
    }
    Thread.sleep(5000)
    print(num)
```

다음 코드는 멀티쓰레드를 활용하여 프로퍼티를 수정하는 과정.

실행할때마다 출력값이 달라지는데, 여러 스레드에서 num 변수를 동시에 변경하려고 시도하는 과정에서의 문제가 발생 (경쟁상태) 이는 코루틴을 이용해도 동일하게 발생한다.

## 가변성 제한하기

코틀린에서 가변성을 제한하는 방법은 다음과 같다

### 읽기 전용 프로퍼티 사용

코틀린의 val 객체를 사용하기 , 이렇게 선언된 프로퍼티는 값처럼 동작하고 일반적인 방법으로는 값이 변하지 않음

단, 값이 완전히 변경 불가능한건 아님. 다음과 같은 경우는 주의할것.

1. 읽기 전용 프로퍼티에 mutable 객체를 저장한 경우
    1. 읽기 전용 프로퍼티는 재할당이 불가능할 뿐. 읽기전용과 가변성을 구분할 것!
2. var 객체의 값을 get으로 사용하는 경우
    1. var는 get/set을 제공하지만 val은 변경이 블가능하므로 get만 사용가능. → val을 var로 오버라이드 가능.

읽기전용 프로퍼티는 불변성을 의미하는 것이 아님을 다시한번 유의! (getter / delegate 등)

### 가변 컬렉션, 읽기 전용 컬렉션 구분하기

코틀린은 읽고 쓸수있는 프로퍼티/ 컬렉션과, 읽기전용 프로퍼티/ 컬렉션으로 구분됨.

→ 컬렉션 계층의 설계 방식에 영향. mutable이 붙은 인터페이스는 대응되는 읽기 전용 인터페이스를 상쇽 받어서, 변경을 위한 메서드를 추가하여 구현함.

이는 위에서 읽기전용 프로퍼티가 게터만, 읽고 쓰기 전용 프로퍼티가 게터와 세터를 모두 가지는것과 비슷

이러한 설계를 통해 저 많은 자유를 얻을수 있는것은 중요. 내부적으로 인터페이스를 사용하고 있으므로 , 실제 컬렉션을 리턴할 수 있기 때문.

다만 이러한 설계는 컬렉선 다운케스팅으로 통해 읽기전용 컬렉션을 mutable한 컬렉션처럼 사용할 수 있다는 문제가 있음.

이이는 예측하지 못한 결과를 초래, 계약 위반이므로 만약 읽기 전용에서 mutable로 변경해야 한다면 copy를 이용

### 데이터 클래스의 copy

string, int같은 내부젓인 상태를 변경하지 않은 immutable 객체를 많이 사용하는 이유 중 다음과 같은 장점이 있음.

> immutable 객체는 set, map의 key로 사용 가능.
> 

mutable 객체는 이렇게 사용할 수 없는데, 이는 세트와 맵이 내부적으로 해시 테이블을 사용하고, 해시 테이블은 터음 요소를 넣을 때 요소의 값을 기반으로 버킷을 형성하기 때문.

→ 요소의 수정이 발생하면 해시 테이블 내부네서 요소를 찾을 수 없어짐.

# 아이템 2: 변수의 스코프 최소화하기

상태를 정의할 때는 변수와 프로퍼티의 스코프를 최소화하는것이 중요.

- 프로퍼티보다는 지역 변수를 사용하는 것이 좋음
- 최대한 좀은 스코프를 갖게 변수를 사용. )→ ex: 반복문 내부에서만 사용되는 변수는 그 내부에서 작성하기.

스코프 : 요소를 볼 수 있는 컴퓨터 프로그램 영역을 말함. 코틀린의 스코프는 기본적으로 중괄호로 만들어짐.

내부 스코프에서 외부 스코프의 요소로만 접근 가능.

다음은 스코프에 대한 예시

```kotlin
val a = 1
fun fizz() {
	val b = 2
	print(a + b)
}
val buzz = {
	val c = 3
	print(a + c)
}
//이 위치에서는 a를 사용할 수 있지만, b와 c는 사용 불가능
```

그렇다면, 변수의 스코프를 최소화할 수 있는 가장 좋은 방법은?

```kotlin
//bad
//user는 for 반복문 스코프 내부뿐만 아니라 외부에서도 사용 가능.
var user: User
for (i in users.indices) {
	user = users[i]
	print("User at $i is $user")
}

//best
//user의 스코프를 for 반복문 내부로 제한.
for ((i, user) in users.withIndex()) {
	print("User at $i is $user")
}
```

스코프를 제한하는 중요한 이유는 **프로그램을 추적하고 관리하기 쉽기 때문**.

프로그램의 변경될 수 있는 부분이 많아지면, 프로그램을 이해하는데 어려워지기 때문.

변수는 읽기 전용 또는 읽고 쓰기 여부와 상관없이 변수를 정의할때 초기화되는것이 좋음.

다음은 If, when, try-catch, Elvis 표현식 등을 활용하여 변수를 정의할 때 초기화하는 예제

```kotlin
//나쁜 예
val user: User
if (hasValue) {
	user = getValue()
} else {
	user = User()
}

//조금 더 좋은 예
val user: User = if(hasValue) {
//if문 내부에서 값 return 하기.
	getValue()
} else {
	User()
}
```

여러 프로퍼티를 한꺼번에 설정해야 하는 경우에는 구조분해 선언 활용하기.

- [ ]  구조분해 선언에 대해 공부하고 정리하기

```kotlin
//나쁜 예
fun updateWeather(degrees: Int) {
	val description: String
	val color: Int
	if(degrees < 5){
		description = "cold"
		color = Color.BLUE
	}else if(degrees < 23){
		description = "mild"
		color = Color.YELLOW
	} else {
		description = "hot"
		color = Color.RED
	}
// ...
}

//조금 더 좋은 예
fun updateWeather(degrees: Int) {
	val (description, color) = when {
		degrees < 5 -> "Cold" to Color.blue
		degrees < 23 -> "Mild" to Color.blue
		else -> "Hot" to Color.blue
	}
// ...
}
```

## 캡처링

다음은 에라토스테네스의 체를 시퀀스를 이용하여 구현한 예제

```kotlin
val primes: Sequence<Int> = sequence {
            var numbers = generateSequence(2) { it+1 }

            while (true){
                val prime = numbers.first()
                yield(prime)
                numbers = numbers.drop(1)
                    .filter { it % prime != 0 }
            }
        }
        print(primes.take(10).toList())
```

만약 위 코드를 다음과 같이 최적화한다면?

1. prime을 var로 선언
2. 반복문 진입하기 전 한번만 생성

```kotlin
val primes: Sequence<Int> = sequence {
        var numbers = generateSequence(2) { it + 1 }

        var prime : Int
        while (true) {
            prime = numbers.first()
            yield(prime)
            numbers = numbers.drop(1)
                .filter { it % prime != 0 }
        }
    }
    print(primes.take(10).toList())
```

→ [2, 3, 5, 6, 7, 8, 9, 10, 11, 12]

위 코드의 실행 결과가 이상하게 나온다.

- [ ]  sequence 스터디 진행, 위 코드의 문제 자세하게 정리하기

## 아이템3: 최대한 플랫폼 타입을 사용하지 말라

코틀린과 함께 소개돤 널 안정성(null-safety)은 코틀린의 주요 기능 중 하나.

따라서 자바에서 자주 볼 수 있었던 NPE는 코틀린에서 찾아보기 힘듬. 하지만 null-safety 메커니즘이 없는 자바 C등의 언어와 코틀린과 연결해서 사용할 때는 예외가 발생할 수 있다.

만약 자바에서 String 타입을 리턴하는 메서드가 있을 때, 코틀린에서 사용하는 방법은?

**@Nullable** 어노테이션이 붙어 있다면 → nullable로 추정하고, String?으로 변경.

**@NotNull** 어노테이션이 붙어 있다면 → **String**으로 변경.

근데 만약 아무것도 안붙어 있다면? 

자바에서는 모두 nullable할 수 있음으로 최대한 안전하게 접근한다면 nullable로 가정하고 다루어야 한다.

하지만 어떤 메서드는 null을 리턴하지 않을 것이 확실할 수도 있다. 이런 경우 not-null(!!)을 사용한다.

이러한 nullable 관련하여 자주 문제되는 부분이 자바의 제네릭 타입이다.

```kotlin
//자바
public class UserRepo {

	public List<User> getUsers() {
		// ***
	}
}

//코틀린
val users: List<User> = UserRepo().users!!.filterNotNull()
```

만약 함수가 List<List>를 리턴하는 경우에는?

```kotlin
val users: List<List<User>> = UserRepo().groupedUsers!!.map { it!!.filterNotNull() }
```

이처럼 널을 확인하는 것 자체로 매우 복잡한 일이 생기며 때문에 다른 프로그래밍 언어에서 넘어온 타입들을 특수하게 다룬다. 이러한 타입을 플랫폼 타입(platform type) 이라고 한다.

플랫폼 타입(platform type): 다른 프로그래밍 언어에서 전달되어 nullable인지 아닌지 알수 없는 타입을 말함.

플랫폼 타입은 String! 처럼 타입 이름 뒤에 ! 기호를 붙여서 표기한다. (물론 노테이션이 직접적으로 코드에 나타나진 않음)

```kotlin
//java
public class UserRepo {
	public User getUser() {
		//...
	}
}

//cotlin
val repo = UserRepo()
val user1 = repo.user					//user1의 타입은 User!
val user2: User = repo.user		//user2의 타입은 User
val user3: User? = repo.user	//user3의 타입은 User?

```

위와 갘이 사용하면 다음과 같이 nullcheck가 더욱 간결해짐

```kotlin
val users: List<User> = UserRepo().users
val users: List<List<User>> = UserRepo().groupedUsers
```

### 안전하지 않는 플랫폼의 위험성

다음 statedType과 platformType 동작 살펴보기

```kotlin
public class JavaClass {
	public String getValue() {
		return null;
	}
}

fun statedType() {
	val value: String = JavaClass().value
	//...
	println(value.length)
}

fun platformType() {
	val value = JavaClass().value
	//...
	println(value.length)
}
```

두 가지 타입 모두 NPE가 발생한다. 일반적으로 개발자는 getValue가 null을 리턴할 것이라고 가정하지 않으므로, 실수했다고 생각할 것이다.

하지만 이 두 코드는 오류의 발생 위치에서 많은 차이가 있다.

### statedType

자바에서 값을 가져오는 위치에서 NPE가 발생한다.

이 위치의 오류의 경우 null이 아니라고 예상을 했지만 null이 나온다는 것을 굉장히 쉽게 알 수 있다. 따라서 코드를 쉽게 수정할 수 있다.

### platformType

값을 활용할 때 NPE가 발생한다.실제로는 저런 간단한 표현식보다 더 복잡한 표현식을 사용할 때 이러한 오류가 발생할 것이다. 플랫폼 타입으로 지정된 변수는 nullable일 수도 있고, 아닐 수도 있음. 따라서 오류를 찾는 데 굉장히 오랜 시간이 걸림. 또한 플랫폼 타입이 전파(다른 곳에서 사용)되는 일은 굉장히 위험하다.

## 아이템4: **inferred 타입으로 리턴하지 말라**

코틀린의 타입 추론(type inference)은 JVM 세계에서 가장 널리 알려진 코틀린의 특징이다.

다만 타입 추론을 사용할 때는 몇 가지 위험한 부분들이 있음. 이러한 위험을 피하려면 할당 때 **inferred 타입은 정확하게 오른쪽에 있는 피연산자에 맞게 설정**된다는 사실을 기억!!. 

절대로 슈퍼클래스 또는 인터페이스로는 설정되지 않음!!

```kotlin
open class Animal
class Zebra: Animal()

fun main() {
	var animal = Zebra()
	animal = Animal()		//오류: Type mismatch
}
```

일반적인 경우엔 이러한 것이 문제가 되지 않음. 원하는 타입보다 제한된 타입이 설정되었다면, 타입을 명시적으로 지정해서 이러한 문제를 해결할 수 있음.

```kotlin
open class Animal
class Zebra: Animal()

fun main() {
	var animal: Animal = Zebra()
	animal = Animal()	//OK
}
```

하지만 직접적으로 라이브러리(또는 모듈)를 조작할 수 없는 경우에는 이러한 문제를 간단하게 해결할수 없음.

그리고 이러한 경우에 inferred 타입을 노출한다면, 위험한 일이 발생할 수 있다.

다음은 CarFactory 인터페이스의 예제.

```kotlin
interface CarFactory {
	fun produce(): Car
}
```

또한 다른 것을 지정하지 않을 경우 디폴트로 생성되는 자동차가 있다고 가정

```kotlin
val DEFAULT_CAR: Car = Fiat126P()
```

대부분의 공장에서 Fiat126P 라는 자동차를 생산하므로, 이를 디폴트로 두었다고 가정.

이후 코드를 작성하다보니 DEFAULT_CAR: Car 로 명시적으로 지정되어 있으므로 따로 필요없다고 판단하여, 함수의 리턴 타입을 제거했다고 가정.

```kotlin
interface CarFactory {
	fun produce() = DEFAULT_CAR
}
```

이후에 다른 사람이 코드를 보다가, DEFAULT_CAR는 타입 추론에 의해 자동으로 타입이 지정될 것이므로,

Car를 명시적으로 지정하지 않아도 된다고 생각해서 다음과 같이 코드를 변경.

```kotlin
val DEFAULT_CAR = Fiat126P()
```

결과 :  CarFactory는 Fiat126P 이외의 자동차를 생산하지 못함.

이처럼 리턴 타입은 API를 사용하는 사용자에게 전달해 줄 수 있는 중요한 정보.

따라서 **리턴 타입은 외부에서 확인할 수 있도록 명시적으로 지정**해 주는 것이 좋다.

## 아이템5: **예외를 활용해 코드에 제한을 걸어라**

확실하게 어떤 형태로 동작해야 하는 코드가 있다면, **예외를 활용해 제한을 걸어주는 게 좋다.**

코틀린에서는 코드의 동작에 제한을 걸 때 다음과 같은 방법을 사용할 수 있음.

1. require 블록 : 아규먼트를 제한할 수 있다.
2. check 블록 : 상태와 관련된 동작을 제한할 수 있다.
3. assert 블록 : 어떤 것이 true인지 확인할 수 있다.)→ Assert 블록은 테스트 모드에서만 작동함
4. return 또는 throw와 함께 활용하는 Elvis 연산자.

다음은 이러한 메커니즘을 사용하는 간단한 예.

```kotlin
//Stack<T>의 일부
fun pop(num: Int = 1): List<T> {
	require(num <= size) {
		"Cannot remove more elements than current size"
	}
	check(isOpen) { "Cannot pop from closed stack" }
	val ret = collection.take(num)
	collection = collection.drop(num)
	assert(ret.size == num)
	return ret
}
```

이렇게  제한을 걸어 주면 다양한 장점이 발생한다.

- 문제가 있을 경우에 함수가 예상하지 못한 동작을 하지 않고 예외를 throw)→ 예상하지 못한 동작을 하는 것은 예외를 던지는것보다 훨씬 더 위험하며 상태관리에 어려움이 있음.
- 코드가 어느정도 자체적으로 검사. 따라서 단위테스트를 감소 가능.
- 스마트 캐스트 기능을 활용할 수 있게 되므로, 캐스트(타입 변환)를 적게 할 수 있다.

### 아규먼트

함수를 정의할 때 타입 시스템을 활용해서 **아규먼트(Argument)에 제한을 거는 코드**를 많이 사용. 몇 가지 예는 다음과 같음.

- 숫자를 아규먼트로 받아서 팩토리얼을 계산한다면 숫자는 양의 정수여야 합니다.
- 좌표들을 아규먼트로 받아서 클러스터를 찾을 때는 비어 있지 않은 좌표 목록이 필요합니다.
- 사용자로부터 메일 주소를 입력받을 때는 값이 입력되어 있는지, 그리고 메일 형식이 올바른지 확인해야 합니다.

```kotlin
fun factorial(n: Int): Long {
	require(n >= 0)
	return if (n <= 1) else factorial(n - 1) * n
}

fun findClusters(points: List<Point>): List<Cluster> {
	require(points.isNotEmpty())
	//...
}

fun sendEmail(user: User, message: String) {
	requireNotNull(user.email)
	require(isValidEmail(user.email))
	//...
}
```

일반적으로 이러한 제한들을 걸 때는 **require 함수를 사용**.

require 함수는 제한을 확인하고, 제한을 만족하지 못하는 경우 예외를 throw.

이와 같은 형태의 입력 유효성 검사 코드는 **함수의 가장 앞부분에 배치**되므로 가독성이 증가됨.

또한 람다를 활용해서 지연 메시지를 정의할 수도 있다.

```kotlin
fun factorial(n: Int): Long {
	require(n >= 0) { "Cannot calculate factorial of $n " + "because it is smaller than 0" }
	return if(n <= 1) 1 else factorial(n - 1) * n
}
```

이처럼 **require 함수는 아규먼트와 관련된 제한을 걸 때 사용**할 수 있다.

이외에도 예외를 활용해 제한을 거는 대표적인 대상으로 상태가 있다.

### 상태

어떤 구체적인 조건을 만족할 때만 함수를 사용할 수 있게 해야 할 때가 있음. 예로는

- 어떤 객체가 미리 초기화되어 있어야만 처리를 하게 하고 싶은 함수
- 사용자가 로그인했을 때만 처리를 하게 하고 싶은 함수
- 객체를 사용할 수 있는 시점에 사용하고 싶은 함수

**상태와 관련된 제한을 걸 때는 일반적으로 check 함수**를 사용함.

```kotlin
fun speak(text: String) {
	check(isInitialized)
	//...
}

fun getUserInfo(): UserInfo {
	checkNotNull(token)
	//...
}

fun next(): T {
	check(isOpen)
	//...
}
```

check 함수는 require 함수와 비슷하지만. 지정된 예측을 만족하지 못할 때, IllegallstateException을 throw.

예외 메시지는 require과 마찬가지로 지연 메시지를 사용해서 변경할 수 있다.

이러한 확인은 사용자가 규약을 어기고, 사용하면 안 되는 곳에서 함수를 호출하고 있다고 의심될 때 사용함.

사용자가 코드를 제대로 사용할 거라고 밎고 있는 것보다는 항상 문제 상황을 예측하고 예외를 주는것이 중요.

### Assert 계열 함수 사용

함수가 올바르게 구현되었다면, 확실하게 참을 낼 수 있는 코드들이 있음.

ex)→ 어떤 함수가 10개의 요소를 리턴한다면 ‘함수가 10개의 요소를 리턴하는가?’ 라는 코드는 항상 참

하지만 에초에 함수 구현단계에서 문제가 있을수 있음. 여러 구현 문제로 발생할 수 있는 추가적인 문제를 예방하려면, 단위 테스트를 사용하는 것이 좋음.

```kotlin
class StackTest {
	@Test
	fun 'Stack pops correct number of elements'() {
		val stack = Stack(20) { it }
		val ret = stack.pop(10)
		assertEquals(10, ret.size)
	}

	//...
}
```

단위 테스트는 구현의 정확성을 확인하는 가장 기본적인 방법이다.

위의 테스트는 스택이 10개의 요소를 팝하면, 10개의 요소가 나온다는 보편적인 사실을 테스트하고 있다.

하지만 위의 한 가지 경우만 테스트해서 모든 상황에서 괜찮을지는 알 수 없다.

따라서 모든 pop 호출 위치에서 제대로 동작하는지 확인한다.

```kotlin
fun pop(num: Int = 1): List<T> {
	//...
	assert(ret.size == num)
	return ret
}
```


단위 테스트에서 assert를 사용하면 다음과 같은 장점이 있다.

- Assert 계열의 함수는 코드를 자체 점검하며, 더 효율적으로 테스트 가능.
- 특정 상황이 아닌 모든 상황에 대한 테스트 가능.
- 실행 시점에 정확하게 어떻게 되는지 확인 가능.
- 실제 코드가 더 빠른 시점에 실패하게 만들어줌

  
### nullability와 스마트 캐스팅

코틀린에서 require과 check 블록으로 어떤 조건을 확인해서 true가 나왔다면, 해당 조건은 이후로도 true일거라 가정한다.

따라서 이를 활용해서 타입 비교를 했다면, **스마트 캐스트가 작동**한다.

다음은 어떤 사람의 복장이 드레스여야 코드가 정상적으로 진행. 따라서 만약 이러한  outfit 프로퍼티가 final이라면 outfit 프로퍼티가 drass로 스마트 캐스트
kotlin
```
fun changeDress(person: Person) {
	require(person.outfit is Dress)
	val dress: Dress = person.outfit		
}
```

이러한 특징은 어떤 대상이 null인지 확인할 때 굉장히 유용하다.

```kotlin
class Person(val email: String?)

fun sendEmail(person: Person, message: String) {
	require(person.email != null)
	val email: String = person.email
  //...
}
```

이러한 경우 requireNotNull / checkNotNull 함수 사용 가능.

```kotlin
fun sendEmail(person: Person, text: String) {
	val email: String = person.email ?: return
	//...
}
```
