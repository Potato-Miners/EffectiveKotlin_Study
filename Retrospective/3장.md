# 🔎 3장 스터디 진행/회고

---

### 📅 스터디 날짜 : July 29, 2023 / August 6, 2023

### 📚 참여 인원 : 2명 (양승민, 최현준)

### 🔖 스터디 장소 : 일산

---



## 📖 agenda.1 - Don't Repeat Yourself

### ➤ Effective Kotlin - 아이템 19/knowledge를 반복하여 사용하지 말라 중...

> 모든 것은 변화한다. 따라서 공통 knowledge가 있다면, 이를 추출해서 이러한 변화에 대비해야 한다.
>
> 여러 요소에 비슷한 부분이 있는 경우, 변경이 필요할 때 실수가 발생할 수 있다. 이런 부분은 추출하는 것이 좋다. 추가적으로 의도하지 않은 수정을 피하려면 또는 다른 곳에서 조작하는 부분이 있다면, 분리해서 사용하는 것이 좋습니다. 많은 개발자는 'Don't Repeat YourSelf'라는 문장을 엄격하게 지키려고 비슷해 보이는 코드는 모두 추출하려는 경향이 있다. 극단적인 것은 언제나 좋지 않다. 항상 균형이 중요하다. 어떤 것을 추출해야 할지 결정하기 어려울 수 있다. 정보 시스템 설계는 예술의 영역과 비슷하기 때문이다. 수많은 시간과 연습이 필요하다.

다음 주제에서는 **'Don't Repeat Yourself'** 라는 문구의 정리와 함께 **단일 책임 원칙(Single Responsibility Principal)** 에 대해서 설명한다.

단일 책임 원칙이란 클래스를 변경하는 이유는 단 한 가지여야 한다는, 코드를 추출해도 되는지를 확인할 수 있는 원칙으로, SOLID 원칙 중 하나이다.



### ➤ 단일 책임 원칙? 원칙이라고 해아할 정도인가? 당연히 지켜져야하는 부분이 아닌가?

라고 생각할 수 있지만, 생각보다 코드를 설계하다 보면 단일 책임 원칙을 당연하다고 생각하면서도, 지키기 애매한 상황이 벌어지기도 한다.

예를 들어, 전체 코드에서 딱 2번만 사용되는 짧은 크기의 계산 로직을 개발한다고 가정해보자.

해당 주제에서 이야기하는 knowledge의 반복을 하지 말라라는 원칙에 의하면 해당 로직은 반드시 따로 단일 책임 원칙을 준수하며 개발을 해야 한다.

독립적인 변경이나 업데이트가 다양한 로직의 경우 원칙을 준수하여 개발하는 것이 큰 도움이 되겠지만, 사실 몇번 사용되지 않고 더 이상 건드려지지 않는 로직은 시간과 노력을 투자하여 독립시켜 개발하기엔 수지가 맞지 않을 수도 있다고 생각한다.

때로는 한정된 자원(시간)에 쫓겨 때로는 지킬 수 없는 것이 더 합리적인 상황이 올 수도 있다. 

따라서 상황에 맞게 유동적인 선택을 하거나, 팀 컨벤션에 의거하여 원칙을 입맞에 맞게 사용하는 것이 좋아 보인다.

---



## 📖 agenda.2 - 언제나 기초를 탄탄히

### ➤ Effective Kotlin - 아이템 20/일반적인 알고리즘을 반복해서 구현하지 말라 중...

>일반적인 알고리즘을 반복해서 만들지 말자. 우선 대부분은 stdlib에 이미 정의되어 있을 가능성이 높다. 따라서 stdlib을 공부해 두면 좋다. stdlib에 없는 일반적인 알고리즘이 필요하거나, 특정 알고리즘을 반복해서 사용해야 하는 경우에는 프로젝트 내부에 직접 정의하기 바란다. 일반적으로 이런 알고리즘들은 확장 함수로 정의하는 것이 좋다.

해당 주제에서의 핵심은 알고리즘을 반복해서 사용하는 것을 예방하는 것도 중요하지만, 결국 stdlib의 활용을 극대화하는 것이라고 생각한다.

stdlib는 가장 기초적인 언제나 항상 모든 언어에서 가장 처음 접하는 기초적인 라이브러리로 언어를 조금 배우다 보면 쉽게 해당 라이브러리 함수의 해석을 간과하고 넘기곤 한다.

결국 해당 언어로 개발을 하다 잘못된 라이브러리의 사용으로 코드의 효율성을 떨어뜨리거나 발견된 오류의 해석이 잘 이루어지지 않는 경우가 발생하기도 한다.

따라서 라이브러리를 접할 때는 해당 함수들에 대해 완벽한 이해를 하도록 노력하고, 완벽하게 이해하지 못했다면 함수의 사용을 지양해야 한다고 생각한다.

---



## 📖 agenda.3 - 섀도잉은 언제 사용될까?

### ➤ Effective Kotlin - 아이템 23/타입 파라미터의 섀도잉을 피하라 중...

>타입 파라미터 섀도잉을 피해라. 타입 파라미터 섀도잉이 발생한 코드는 이해하기 어려울 수 있다. 타입 파라미터가 섀도잉되는 경우에는 코드를 주의해서 살펴보아야 한다.

**타입 파라미터 섀도잉(Type Parameter Shadowing)** 은 Java와 같은 언어에서 제네릭 프로그래밍을 할 때 발생하는 현상이다. 이는 주로 메서드나 클래스의 타입 파라미터 이름이 외부 스코프에서 이미 사용되는 변수 이름과 같을 때 발생한다. 이로 인해 타입 파라미터의 이름이 외부 변수 이름을 가리는 현상이 생기는데, 이것을 "섀도잉"이라고 한다.

섀도잉은 코드의 가독성을 떨어뜨릴 수 있으며, 프로그래머가 의도하지 않은 결과를 초래할 수도 있다. 타입 파라미터 섀도잉은 아래와 같은 상황에서 주로 발생한다.

+ **메서드나 클래스의 타입 파라미터 이름과 메서드/클래스 내부에서 사용되는 변수 이름이 같을 때.**
+ **중첩된 제네릭 클래스에서 외부 클래스의 타입 파라미터 이름과 중첩 클래스의 타입 파라미터 이름이 같을 때.**
+ **제네릭 클래스를 상속하는 하위 클래스에서 부모 클래스의 타입 파라미터 이름과 하위 클래스의 타입 파라미터 이름이 같을 때.**

이러한 경우에는 이름 충돌이 발생하게 되어 의도하지 않은 동작이나 컴파일 에러를 유발할 수 있다. 이를 방지하기 위해서는 변수나 클래스/메서드 이름을 잘 선택하고, 코드의 가독성을 높이는 노력을 기울이는 것이 좋아보인다.

---



## 📖 agenda.4 - variance(변이성)

### ➤ Effective Kotlin - 아이템 24/제네릭 타입과 variance 한정자를 활용하라 중...

코틀린에서 variance(변이성)는 제네릭 클래스의 타입 인자 간 서로 상속 관계를 지정하는 개념이다. 즉, 타입 인자의 하위 타입 관계를 제대로 다루기 위한 문법적인 지원이다. 코틀린은 세 가지 variance 한정자를 제공합니다: `in`, `out`, 그리고 기본적으로 variance가 없는 `일반적` 상태이다.

+ `in` : 하위 타입 관계가 역전된다.
+ `out` : 상위 타입 관계가 유지된다.
+ 기본적으로는 변화가 없는, 일반적인 상태이다.

이러한 variance 한정자는 주로 리턴 타입과 파라미터 타입의 관계를 나타낼 때 사용된다. 이를 통해 제네릭 클래스가 더 유연하게 하위 타입 관계를 다룰 수 있게 된다.

+ `in` : `in` 한정자는 파라미터 관계를 표현한다. 예를 들어 `Consumer<in T>`는 `T`의 상위 타입을 받을 수 있다.
+ `out` : `out` 한정자는 리턴 관계를 표현한다. 예를 들어 `Producer<out T>`는 `T`의 하위 타입을 리턴할 수 있다.
+ 일반적인 상태 : variance 한정자를 사용하지 않을 경우, 하위 타입 관계도, 상위 타입 관계도 유지되지 않는다. 일반적인 경우로써 어떤 특정한 variance 관계를 강제하거나 허용하지 않을 때 사용된다.

간단한 예시로, **`List<out T>`**는 `T`의 하위 타입 관계가 유지되기 때문에 다음 코드가 가능하다.

```kotlin
val ints: List<Int> = listOf(1, 2, 3)
val numbers: List<Number> = ints // List<out T>이므로 가능
```

**`Consumer<in T>`**의 경우는 반대로, `T`의 상위 타입 관계가 유지되기 때문에 다음 코드가 가능하다.

```kotlin
fun addToConsumer(consumer: Consumer<in Int>, value: Int) {
    // ...
}

val numberConsumer: Consumer<Number> = ...
addToConsumer(numberConsumer, 42) // Consumer<in T>이므로 가능
```



### ➤ 안드로이드 개발에서 사용되는 variance

안드로이드에서 Retrofit과 같은 라이브러리를 사용할 때, 네트워크 요청의 성공과 실패를 처리하는 콜백 함수로써 `onSuccess`와 `onFailure`를 많이 사용한다. 이때 코틀린의 variance를 활용하여 콜백 함수의 매개변수 타입을 유연하게 다룰 수 있다.

보통 Retrofit의 `enqueue` 메서드에서 `Callback`을 구현한 익명 클래스를 사용한다. 아래의 예시 코드에서는 `Call` 객체의 응답을 받아 처리하는 상황을 가정한다.

```kotlin
interface Callback<T> {
    fun onSuccess(response: T)
    fun onFailure(error: Throwable)
}

class Call<T> {
    fun enqueue(callback: Callback<T>) {
        // 네트워크 요청 후 응답 처리
        val response: T = ...
        
        callback.onSuccess(response)
    }
}
```

이때 `onSuccess`와 `onFailure` 함수에서 코틀린의 variance를 사용할 수 있다.

+ `onSuccess` 함수에서는 `T`를 리턴 타입 관계로 설정한다. 왜냐하면 이 함수는 `Call` 객체의 응답을 받아와서 사용자에게 제공하기 때문에, 응답이 `T`의 하위 타입일 수 있어야 한다.
+ `onFailure` 함수에서는 `Throwable`을 사용한다. `Throwable`은 모든 예외 클래스의 슈퍼 클래스이므로, 하위 타입 관계를 유지해야 한다. 따라서 `Throwable`은 리턴 타입 관계로 설정합니다.

```kotlin
class Call<T> {
    fun enqueue(callback: Callback<T>) {
        try {
            // 네트워크 요청 후 응답 처리
            val response: T = ...
            callback.onSuccess(response)
        } catch (error: Throwable) {
            callback.onFailure(error)
        }
    }
}
```

이렇게 함으로써, `onSuccess` 함수와 `onFailure` 함수에서 각각 제네릭 타입 `T`와 `Throwable`의 관계를 제대로 표현할 수 있게 된다.

---



## 📖 agenda.5 - 아직 꿈만 같은 풀스택 개발에서의 재사용성

### ➤ Effective Kotlin - 아이템 25/공통 모듈을 추출해서 여러 플랫폼에서 재사용하라 중...

> 코틀린을 사용하면 널리 사용되는 대부분의 장치와 플랫폼을 대상으로 개발할 수 있으며, 원하는 코드들을 재사용할 수 있다. 코틀린으로 작성할 수 있는 것들의 예를 간단하게 설명해 보겠다.
>
> + 코틀린/JVM을 사용한 백엔드 개발 - 스프링, Ktor 등
> + 코틀린/JS를 사용한 웹사이트 개발 - 리액트 등
> + 코틀린/JVM을 사용한 안드로이드 개발 - 안드로이드 SDK 등
> + 코틀린/네이티브를 통해 Objective-C/스위프트로 iOS 프레임워크 개발
> + 코틀린/JVM을 사용한 데스크톱 개발 - TornadoFX 등
> + 코틀린/네이티브를 사용한 라즈베리파이, 리눅스, macOS 프로그램 개발

풀스택 개발을 한 가지의 언어를 통해 할 수 있다는 것은 개발자에게 꿈만 같은 일이다.

당장 프론트엔드/백엔드의 개념이 아니어도, 스프링 백엔드에서 코틀린을 사용하는 것(코프링)은 아직까지는 불안정하고 안정성이 떨어지는 선택이라고 알고 있다.

이유는 스프링 프레임워크에서 사용되는 JPA Hibernate의 호환이 Java에서는 나름 최적화가 되어있지만, 코틀린에서는 사용하기 힘든 적용을 보여준다고 들었다.

이렇듯 백엔드 개발 안에서도 이렇게 언어를 하나로 통합하여 재사용하기 힘든데, 웹 전반을 모두 같은 언어로 통합 개발할 수 있다는 것은 쉬운일이 아닐 것이다.



### ➤ 모든 개발에서 재사용을 할 수 있는 것이 과연 좋을까?

나는 좋다고 생각하지 않는다. 개발에서 재사용은 물론 개발에서의 어마어마한 이득을 가져다 준다.

리소스 사용에 있어서의 효율성이라던지, 모든 개발자가 하나의 언어로 통일하여 개발할 수 있어 실수나 오류를 줄일 수 있다던지 말이다.

하지만 세상에 개발을 위한 여러 언어가 등장한 데에는 그만한 이유가 있다고 생각한다. 풀스택 개발을 예로 들면,

크게 프론트엔드와 백엔드 개발로 나눠진다. 궁극적으로는 웹 서비스를 퍼블리싱하는 동시의 목표를 가지고 있지만, 각 분야에서 추구하는 효율을 위한 개발 방향은 다를 수 있다.

따라서 각각의 목표와 방향에 매칭되는 언어 또는 각각의 분야를 더 효율적이고 빠르게 개발하기 위해 존재하는 언어들이라고 생각한다.

이렇게 생각한다면 오히려 섣부른 코드의 재사용은 각각의 분야를 개발하는 데 있어서 좋지 않은 영향을 끼칠 수도 있지 않을까라고 생각한다.

---

